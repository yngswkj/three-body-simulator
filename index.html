<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ä¸‰ä½“å•é¡Œã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ - é‡åŠ›ç³»ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³</title>
    <meta name="description" content="ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ä¸‰ä½“å•é¡Œã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ãƒ¼ã€‚é‡åŠ›ç›¸äº’ä½œç”¨ã«ã‚ˆã‚‹å¤©ä½“ã®è»Œé“ã‚’å¯è¦–åŒ–ã—ã¾ã™ã€‚">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
            background: linear-gradient(135deg, #0a0a1f 0%, #1a1a3a 50%, #2d1b69 100%);
            color: white;
            overflow-x: hidden;
            min-height: 100vh;
            position: relative;
        }

        /* èƒŒæ™¯ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background:
                radial-gradient(circle at 20% 30%, rgba(120, 119, 198, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 80% 70%, rgba(255, 107, 107, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 40% 80%, rgba(78, 205, 196, 0.1) 0%, transparent 50%);
            pointer-events: none;
            z-index: -1;
        }

        .container {
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            max-height: 100vh;
            /* â˜… è¿½åŠ ï¼šæœ€å¤§é«˜ã•ã‚’ç”»é¢ã‚µã‚¤ã‚ºã«åˆ¶é™ */
            overflow: hidden;
            /* â˜… è¿½åŠ ï¼šã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ãƒãƒ¼ã‚’é˜²ã */
        }

        .header {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(20px);
            padding: 10px 10px;
            text-align: center;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
        }

        .header h1 {
            font-size: 24px;
            margin-bottom: 8px;
            background: linear-gradient(135deg, #ff6b6b, #4ecdc4, #45b7d1);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            font-weight: 700;
            letter-spacing: -0.5px;
        }

        .header .subtitle {
            font-size: 13px;
            opacity: 0.7;
            color: #a29bfe;
            margin-bottom: 8px;
        }

        .header .instructions {
            font-size: 11px;
            opacity: 0.6;
            color: #74b9ff;
            background: rgba(116, 185, 255, 0.1);
            padding: 8px 12px;
            border-radius: 8px;
            border: 1px solid rgba(116, 185, 255, 0.2);
            display: inline-block;
        }

        .canvas-container {
            flex: 1;
            position: relative;
            background: radial-gradient(circle at center, rgba(26, 26, 58, 0.8) 0%, rgba(15, 15, 35, 0.9) 100%);
            min-height: 300px;
            /* â˜… å¤‰æ›´ï¼šæœ€å°é«˜ã•ã‚’å°ã•ã */
            overflow: hidden;
            /* â˜… è¿½åŠ ï¼šã‚ªãƒ¼ãƒãƒ¼ãƒ•ãƒ­ãƒ¼ã‚’é˜²ã */
        }

        #canvas {
            width: 100%;
            height: 100%;
            display: block;
            touch-action: none;
            border-radius: 0;
            cursor: crosshair;
        }

        .controls {
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(20px);
            padding: 15px;
            /* â˜… å¤‰æ›´ï¼šãƒ‘ãƒ‡ã‚£ãƒ³ã‚°ã‚’å°ã•ã */
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 -4px 20px rgba(0, 0, 0, 0.2);
            flex-shrink: 0;
            /* â˜… è¿½åŠ ï¼šã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ãƒ‘ãƒãƒ«ãŒç¸®ã¾ãªã„ã‚ˆã†ã«ã™ã‚‹ */
            max-height: 40vh;
            /* â˜… è¿½åŠ ï¼šæœ€å¤§é«˜ã•ã‚’ç”»é¢ã®40%ã«åˆ¶é™ */
            overflow-y: auto;
            /* â˜… è¿½åŠ ï¼šå¿…è¦ã«å¿œã˜ã¦ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ« */
        }

        .main-controls {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            /* â˜… å¤‰æ›´ï¼šã‚®ãƒ£ãƒƒãƒ—ã‚’å°ã•ã */
            margin-bottom: 15px;
            /* â˜… å¤‰æ›´ï¼šãƒãƒ¼ã‚¸ãƒ³ã‚’å°ã•ã */
        }

        .control-section {
            margin-bottom: 12px;
            /* â˜… å¤‰æ›´ï¼šãƒãƒ¼ã‚¸ãƒ³ã‚’å°ã•ã */
        }

        .control-section:last-child {
            margin-bottom: 0;
        }

        .section-title {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.6);
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-weight: 500;
        }

        button {
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.8) 0%, rgba(118, 75, 162, 0.8) 100%);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: white;
            padding: 12px 14px;
            /* â˜… å¤‰æ›´ï¼šãƒ‘ãƒ‡ã‚£ãƒ³ã‚°ã‚’å°ã•ã */
            border-radius: 12px;
            font-size: 13px;
            /* â˜… å¤‰æ›´ï¼šãƒ•ã‚©ãƒ³ãƒˆã‚µã‚¤ã‚ºã‚’å°ã•ã */
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            font-weight: 500;
            position: relative;
            overflow: hidden;
            backdrop-filter: blur(10px);
        }

        button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s;
        }

        button:hover::before {
            left: 100%;
        }

        button:hover {
            transform: translateY(-1px);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.3);
            border-color: rgba(255, 255, 255, 0.2);
        }

        button:active {
            transform: translateY(0);
        }

        button.active {
            background: linear-gradient(135deg, rgba(255, 107, 107, 0.9) 0%, rgba(238, 90, 36, 0.9) 100%);
            box-shadow: 0 4px 20px rgba(255, 107, 107, 0.4);
        }

        .slider-row {
            display: flex;
            align-items: center;
            gap: 10px;
            /* â˜… å¤‰æ›´ï¼šã‚®ãƒ£ãƒƒãƒ—ã‚’å°ã•ã */
            margin-bottom: 10px;
            /* â˜… å¤‰æ›´ï¼šãƒãƒ¼ã‚¸ãƒ³ã‚’å°ã•ã */
        }

        .slider-row:last-child {
            margin-bottom: 0;
        }

        .slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
            flex: 1;
        }

        .slider {
            flex: 1;
            height: 6px;
            border-radius: 3px;
            background: rgba(255, 255, 255, 0.1);
            outline: none;
            -webkit-appearance: none;
            appearance: none;
            position: relative;
        }

        .slider::-webkit-slider-track {
            height: 6px;
            border-radius: 3px;
            background: rgba(255, 255, 255, 0.1);
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(135deg, #4ecdc4 0%, #44a08d 100%);
            cursor: pointer;
            box-shadow: 0 2px 10px rgba(78, 205, 196, 0.4);
            border: 2px solid rgba(255, 255, 255, 0.2);
            transition: all 0.2s ease;
        }

        .slider::-webkit-slider-thumb:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 15px rgba(78, 205, 196, 0.6);
        }

        .slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(135deg, #4ecdc4 0%, #44a08d 100%);
            cursor: pointer;
            border: 2px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 2px 10px rgba(78, 205, 196, 0.4);
        }

        .value-display {
            font-size: 13px;
            color: #4ecdc4;
            min-width: 50px;
            text-align: right;
            font-weight: 500;
            padding: 4px 8px;
            background: rgba(78, 205, 196, 0.1);
            border-radius: 6px;
            border: 1px solid rgba(78, 205, 196, 0.2);
        }

        .slider-label {
            font-size: 13px;
            color: rgba(255, 255, 255, 0.8);
            min-width: 50px;
            font-weight: 500;
        }

        .preset-buttons {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
        }

        .preset-btn {
            padding: 10px 8px;
            /* â˜… å¤‰æ›´ï¼šãƒ‘ãƒ‡ã‚£ãƒ³ã‚°ã‚’å°ã•ã */
            font-size: 11px;
            /* â˜… å¤‰æ›´ï¼šãƒ•ã‚©ãƒ³ãƒˆã‚µã‚¤ã‚ºã‚’å°ã•ã */
            background: linear-gradient(135deg, rgba(78, 205, 196, 0.8) 0%, rgba(68, 160, 141, 0.8) 100%);
            border: 1px solid rgba(78, 205, 196, 0.3);
        }

        .info {
            position: absolute;
            top: 15px;
            left: 15px;
            font-size: 12px;
            color: rgba(255, 255, 255, 0.8);
            background: rgba(0, 0, 0, 0.4);
            padding: 12px 15px;
            border-radius: 10px;
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        .info-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 4px;
        }

        .info-row:last-child {
            margin-bottom: 0;
        }

        .info-label {
            color: rgba(255, 255, 255, 0.6);
        }

        .info-value {
            color: #4ecdc4;
            font-weight: 500;
            margin-left: 10px;
        }

        .trail-controls {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        /* â˜… è¿½åŠ ï¼šç‰©ç†è¨­å®šã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ç”¨ã®ã‚¹ã‚¿ã‚¤ãƒ« */
        .physics-controls {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .trail-toggle {
            padding: 8px 12px;
            font-size: 12px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            min-width: 80px;
            text-align: center;
        }

        .trail-toggle.active {
            background: linear-gradient(135deg, #4ecdc4 0%, #44a08d 100%);
            border-color: #4ecdc4;
        }

        .error-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 107, 107, 0.2);
            border: 1px solid rgba(255, 107, 107, 0.5);
            color: #ff6b6b;
            padding: 15px 20px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            display: none;
            z-index: 1000;
        }

        /* â˜… è¿½åŠ ï¼šãƒ„ãƒ¼ãƒ«ãƒãƒƒãƒ—ã®ã‚¹ã‚¿ã‚¤ãƒ« */
        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(15px);
            color: white;
            padding: 12px 16px;
            border-radius: 8px;
            font-size: 12px;
            line-height: 1.4;
            pointer-events: none;
            z-index: 1000;
            display: none;
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            min-width: 180px;
        }

        .tooltip-title {
            font-weight: bold;
            color: #4ecdc4;
            margin-bottom: 6px;
            font-size: 13px;
        }

        .tooltip-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 3px;
        }

        .tooltip-row:last-child {
            margin-bottom: 0;
        }

        .tooltip-label {
            color: rgba(255, 255, 255, 0.7);
        }

        .tooltip-value {
            color: #ffffff;
            font-weight: 500;
            margin-left: 10px;
        }

        /* â˜… è¿½åŠ ï¼šç‰¹æ®Šå¤©ä½“ã‚¿ã‚¤ãƒ—åˆ¥ã®è‰²åˆ†ã‘ */
        .tooltip.pulsar .tooltip-title {
            color: #00FFFF;
        }

        .tooltip.blackHole .tooltip-title {
            color: #ff6b6b;
        }

        .tooltip.neutronStar .tooltip-title {
            color: #E6E6FA;
        }

        .tooltip.whiteDwarf .tooltip-title {
            color: #F0F8FF;
        }

        .tooltip.planetSystem .tooltip-title {
            color: #FFD700;
        }

        @media (max-width: 380px) {
            .header h1 {
                font-size: 20px;
            }

            .main-controls {
                grid-template-columns: 1fr 1fr;
                gap: 8px;
            }

            button {
                padding: 12px 14px;
                font-size: 13px;
            }

            .preset-buttons {
                grid-template-columns: 1fr;
            }

            .header .instructions {
                font-size: 10px;
                padding: 6px 10px;
            }
        }

        /* è¿½åŠ ã®ã‚°ãƒ­ãƒ¼åŠ¹æœ */
        .glow {
            animation: glow 2s ease-in-out infinite alternate;
        }

        @keyframes glow {
            from {
                box-shadow: 0 0 5px rgba(78, 205, 196, 0.2);
            }

            to {
                box-shadow: 0 0 20px rgba(78, 205, 196, 0.4);
            }
        }

        /* â˜… è¿½åŠ ï¼šå¤§ç”»é¢ç”¨ã®ãƒ¡ãƒ‡ã‚£ã‚¢ã‚¯ã‚¨ãƒª */
        @media (min-width: 768px) {
            .header {
                /* ãƒ˜ãƒƒãƒ€ãƒ¼ã¯å¤§ç”»é¢ã§ã‚‚ä¸Šéƒ¨ã«å›ºå®š */
                flex-shrink: 0;
            }

            .container {
                /* ã‚³ãƒ³ãƒ†ãƒŠã¯ç¸¦æ–¹å‘ã®ã¾ã¾ */
                flex-direction: column;
            }

            /* æ–°ã—ã„ã‚³ãƒ³ãƒ†ãƒŠã§canvasã¨controlsã‚’æ¨ªä¸¦ã³ã« */
            .main-content {
                display: flex;
                flex-direction: row;
                flex: 1;
                overflow: hidden;
            }

            .canvas-container {
                flex: 1;
                min-height: calc(100vh - 120px);
                /* ãƒ˜ãƒƒãƒ€ãƒ¼åˆ†ã‚’é™¤ã„ãŸé«˜ã• */
            }

            .controls {
                width: 380px;
                /* å›ºå®šå¹… */
                max-height: calc(100vh - 120px);
                /* ãƒ˜ãƒƒãƒ€ãƒ¼åˆ†ã‚’é™¤ã„ãŸé«˜ã• */
                padding: 20px;
                border-top: none;
                /* ä¸Šãƒœãƒ¼ãƒ€ãƒ¼ã‚’å‰Šé™¤ */
                border-left: 1px solid rgba(255, 255, 255, 0.1);
                /* å·¦ãƒœãƒ¼ãƒ€ãƒ¼ã‚’è¿½åŠ  */
                box-shadow: -4px 0 20px rgba(0, 0, 0, 0.2);
                /* å·¦å´ã‚·ãƒ£ãƒ‰ã‚¦ */
            }

            .main-controls {
                gap: 12px;
                margin-bottom: 20px;
            }

            .control-section {
                margin-bottom: 16px;
            }

            button {
                padding: 14px 16px;
                font-size: 14px;
            }

            .preset-btn {
                padding: 12px 10px;
                font-size: 12px;
            }

            .slider-row {
                gap: 12px;
                margin-bottom: 12px;
            }
        }

        /* â˜… è¿½åŠ ï¼šè¶…å¤§ç”»é¢ç”¨ã®èª¿æ•´ */
        @media (min-width: 1200px) {
            .controls {
                width: 380px;
                /* è¶…å¤§ç”»é¢ã§ã¯å¹…ã‚’å°‘ã—åºƒã */
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="header">
            <h1>ä¸‰ä½“å•é¡Œã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿</h1>
            <div class="subtitle">é‡åŠ›ç›¸äº’ä½œç”¨ã«ã‚ˆã‚‹å¤©ä½“è»Œé“ã®å¯è¦–åŒ–ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³</div>
            <div class="instructions">
                ğŸ“± ã‚¿ãƒƒãƒ—/ã‚¯ãƒªãƒƒã‚¯: å¤©ä½“é…ç½® | ğŸ–±ï¸ ãƒ‰ãƒ©ãƒƒã‚°: å¤©ä½“ç§»å‹• | âš™ï¸ ãƒ—ãƒªã‚»ãƒƒãƒˆ: æ—¢çŸ¥ã®è»Œé“é…ç½®
            </div>
        </div>

        <!-- â˜… è¿½åŠ ï¼šå¤§ç”»é¢ç”¨ã®ãƒ¡ã‚¤ãƒ³ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ãƒ©ãƒƒãƒ‘ãƒ¼ -->
        <div class="main-content">
            <div class="canvas-container">
                <canvas id="canvas"></canvas>
                <div class="info">
                    <div class="info-row">
                        <span class="info-label">å¤©ä½“æ•°</span>
                        <span class="info-value" id="bodyCount">0</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">æ™‚é–“</span>
                        <span class="info-value" id="timeDisplay">0</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">ã‚¨ãƒãƒ«ã‚®ãƒ¼</span>
                        <span class="info-value" id="energyDisplay">0</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">FPS</span>
                        <span class="info-value" id="fpsDisplay">60</span>
                    </div>
                </div>
                <div class="error-message" id="errorMessage">
                    ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ãŒä¸å®‰å®šã«ãªã‚Šã¾ã—ãŸã€‚ãƒªã‚»ãƒƒãƒˆã—ã¦ãã ã•ã„ã€‚
                </div>
            </div>

            <div class="controls">
                <div class="main-controls">
                    <button id="playPause">é–‹å§‹</button>
                    <button id="reset">ãƒªã‚»ãƒƒãƒˆ</button>
                    <button id="clear">ã‚¯ãƒªã‚¢</button>
                </div>

                <div class="control-section">
                    <div class="section-title">ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³è¨­å®š</div>
                    <div class="slider-row">
                        <span class="slider-label">é€Ÿåº¦</span>
                        <div class="slider-container">
                            <input type="range" id="speedSlider" class="slider" min="1" max="5" step="0.1" value="1.0">
                            <span class="value-display" id="speedValue">1.0</span>
                        </div>
                    </div>
                    <div class="slider-row">
                        <span class="slider-label">é‡åŠ›</span>
                        <div class="slider-container">
                            <input type="range" id="gravitySlider" class="slider" min="50" max="300" step="25"
                                value="150">
                            <span class="value-display" id="gravityValue">150</span>
                        </div>
                    </div>
                    <div class="slider-row">
                        <span class="slider-label">è¡çªåˆ¤å®š</span>
                        <div class="slider-container">
                            <input type="range" id="collisionSensitivitySlider" class="slider" min="0.1" max="1.0"
                                step="0.1" value="0.5">
                            <span class="value-display" id="collisionSensitivityValue">0.5</span>
                        </div>
                    </div>
                </div>

                <div class="control-section">
                    <div class="section-title">è»Œè·¡è¨­å®š</div>
                    <div class="trail-controls">
                        <button class="trail-toggle active" id="trailToggle">è»Œè·¡è¡¨ç¤º</button>
                        <div class="slider-container">
                            <span class="slider-label">é•·ã•</span>
                            <input type="range" id="trailSlider" class="slider" min="10" max="1000" step="10"
                                value="30">
                            <span class="value-display" id="trailValue">30</span>
                        </div>
                    </div>
                </div>

                <!-- â˜… ä¿®æ­£ï¼šè¡çªè¨­å®šã¨é‡åŠ›å ´å¯è¦–åŒ–ã‚’æ¨ªä¸¦ã³ã« -->
                <div class="control-section">
                    <div class="section-title">ç‰©ç†è¨­å®š</div>
                    <div class="physics-controls">
                        <button class="trail-toggle active" id="collisionToggle">è¡çªæœ‰åŠ¹</button>
                        <button class="trail-toggle" id="gravityFieldToggle">é‡åŠ›å ´éè¡¨ç¤º</button>
                    </div>
                    <!-- â˜… è¿½åŠ ï¼šè¡çªåˆ¤å®šã®å³ã—ã•ã‚’èª¿ç¯€ã™ã‚‹ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ -->
                </div>

                <div class="control-section">
                    <div class="section-title">ãƒ—ãƒªã‚»ãƒƒãƒˆé…ç½®</div>
                    <div class="preset-buttons">
                        <button class="preset-btn" onclick="setPreset('binary')">é€£æ˜Ÿç³»</button>
                        <button class="preset-btn" onclick="setPreset('triangle')">ä¸‰è§’é…ç½®</button>
                        <button class="preset-btn" onclick="setPreset('figure_eight')">8ã®å­—è»Œé“</button>
                        <button class="preset-btn" onclick="setPreset('random')">ãƒ©ãƒ³ãƒ€ãƒ </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        'use strict';

        // ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let bodies = [];
        let isRunning = false;
        let animationId = null;
        let time = 0;
        let selectedBody = null;
        let isDragging = false;
        let dragOffset = { x: 0, y: 0 };

        // ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
        let timeStep = 0.016;  // 60FPSã§ç´„16ms
        let speed = 1.0;
        let gravity = 150;

        // è»Œè·¡è¡¨ç¤ºç”¨ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã¨ã‚¨ãƒ©ãƒ¼ã‚«ã‚¦ãƒ³ãƒˆ
        let trailLength = 30;
        let showTrails = true;
        let errorCount = 0;

        // â˜… è¿½åŠ ï¼šè¡çªåˆ¤å®šãƒ•ãƒ©ã‚°
        let enableCollisions = true;

        // â˜… è¿½åŠ ï¼šè¡çªåˆ¤å®šã®æ„Ÿåº¦ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
        let collisionSensitivity = 0.5; // 0.1(å³ã—ã„) ï½ 1.0(ç·©ã„)

        // â˜… è¿½åŠ ï¼šãƒ–ãƒ©ãƒƒã‚¯ãƒ›ãƒ¼ãƒ«é–¢é€£å®šæ•°
        const BLACK_HOLE_MASS_THRESHOLD = 400; // â˜… å¤‰æ›´ï¼šãƒ–ãƒ©ãƒƒã‚¯ãƒ›ãƒ¼ãƒ«åŒ–ã™ã‚‹è³ªé‡ã®é–¾å€¤ã‚’å³ã—ãï¼ˆ200â†’300ï¼‰
        const BLACK_HOLE_GRAVITY_MULTIPLIER = 3; // ãƒ–ãƒ©ãƒƒã‚¯ãƒ›ãƒ¼ãƒ«ã®é‡åŠ›å€ç‡

        // â˜… è¿½åŠ ï¼šæ–°ã—ã„å¤©ä½“ã‚¿ã‚¤ãƒ—ã®é–¾å€¤
        const WHITE_DWARF_MASS_THRESHOLD = 80;   // ç™½è‰²çŸ®æ˜ŸåŒ–ã™ã‚‹è³ªé‡ã®é–¾å€¤
        const PULSAR_MASS_THRESHOLD = 160;       // ãƒ‘ãƒ«ã‚µãƒ¼åŒ–ã™ã‚‹è³ªé‡ã®é–¾å€¤
        const NEUTRON_STAR_MASS_THRESHOLD = 190; // ä¸­æ€§å­æ˜ŸåŒ–ã™ã‚‹è³ªé‡ã®é–¾å€¤
        const PLANET_SYSTEM_MASS_THRESHOLD = 250; // æƒ‘æ˜Ÿç³»åŒ–ã™ã‚‹è³ªé‡ã®é–¾å€¤

        // â˜… è¿½åŠ ï¼šé‡åŠ›å ´å¯è¦–åŒ–é–¢é€£
        let showGravityField = false;
        let gravityFieldResolution = 60; // â˜… å¤‰æ›´ï¼šè§£åƒåº¦ã‚’å€å¢—ï¼ˆ30â†’60ï¼‰
        let gravityFieldCanvas = null;
        let gravityFieldCtx = null;
        let gravityFieldUpdateCounter = 0; // æ›´æ–°é »åº¦åˆ¶å¾¡ç”¨

        // æ˜Ÿã®èƒŒæ™¯ç”¨å¤‰æ•°
        let stars = [];
        let backgroundGenerated = false;

        // FPSè¨ˆæ¸¬ç”¨å¤‰æ•°
        let frameCount = 0;
        let lastFpsUpdate = Date.now();
        let currentFps = 60;

        // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«é…åˆ—ã‚’ã‚°ãƒ­ãƒ¼ãƒãƒ«ã«å®šç¾©
        let particles = [];

        // ç¾åœ¨ã®ãƒ—ãƒªã‚»ãƒƒãƒˆã‚’è¨˜æ†¶
        let currentPresetType = null;

        /**
         * ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚µã‚¤ã‚ºè¨­å®š
         */
        function resizeCanvas() {
            try {
                const container = canvas.parentElement;
                const newWidth = container.clientWidth;
                const newHeight = container.clientHeight;

                if (canvas.width !== newWidth || canvas.height !== newHeight) {
                    canvas.width = newWidth;
                    canvas.height = newHeight;
                    generateStars(); // ã‚µã‚¤ã‚ºå¤‰æ›´æ™‚ã«æ˜Ÿã‚’å†ç”Ÿæˆ

                    // â˜… è¿½åŠ ï¼šé‡åŠ›å ´ã‚­ãƒ£ãƒ³ãƒã‚¹ã®ãƒªã‚µã‚¤ã‚º
                    setupGravityFieldCanvas();
                }
            } catch (error) {
                console.warn('Canvas resize error:', error);
            }
        }

        // â˜… è¿½åŠ ï¼šé‡åŠ›å ´ã‚­ãƒ£ãƒ³ãƒã‚¹ã®è¨­å®š
        function setupGravityFieldCanvas() {
            if (!gravityFieldCanvas) {
                gravityFieldCanvas = document.createElement('canvas');
                gravityFieldCtx = gravityFieldCanvas.getContext('2d');
            }
            gravityFieldCanvas.width = canvas.width;
            gravityFieldCanvas.height = canvas.height;
        }

        // â˜… è¿½åŠ ï¼šé‡åŠ›å ´ã®è¨ˆç®—ã¨æç”»
        function calculateAndDrawGravityField() {
            if (!showGravityField || bodies.length === 0) return;

            // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã®ãŸã‚3ãƒ•ãƒ¬ãƒ¼ãƒ ã«1å›æ›´æ–°
            gravityFieldUpdateCounter++;
            if (gravityFieldUpdateCounter % 3 !== 0) return;

            const width = canvas.width;
            const height = canvas.height;
            const stepX = width / gravityFieldResolution;
            const stepY = height / gravityFieldResolution;

            // é‡åŠ›å ´ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚’ã‚¯ãƒªã‚¢
            gravityFieldCtx.clearRect(0, 0, width, height);

            // â˜… å¤‰æ›´ï¼šé‡åŠ›å ´å¼·åº¦ã‚’è¨ˆç®—ï¼ˆãƒãƒ†ãƒ³ã‚·ãƒ£ãƒ«ã§ã¯ãªãé‡åŠ›åŠ é€Ÿåº¦ï¼‰
            let minFieldStrength = Infinity;
            let maxFieldStrength = -Infinity;
            const fieldStrengths = [];

            for (let i = 0; i <= gravityFieldResolution; i++) {
                fieldStrengths[i] = [];
                for (let j = 0; j <= gravityFieldResolution; j++) {
                    const x = i * stepX;
                    const y = j * stepY;
                    const fieldStrength = calculateGravityFieldStrength(x, y);
                    fieldStrengths[i][j] = fieldStrength;

                    if (fieldStrength < minFieldStrength) minFieldStrength = fieldStrength;
                    if (fieldStrength > maxFieldStrength) maxFieldStrength = fieldStrength;
                }
            }

            // â˜… å¤‰æ›´ï¼šå¯¾æ•°ã‚¹ã‚±ãƒ¼ãƒ«ã§æ­£è¦åŒ–ï¼ˆé‡åŠ›å ´ã®åºƒã„ãƒ€ã‚¤ãƒŠãƒŸãƒƒã‚¯ãƒ¬ãƒ³ã‚¸ã«å¯¾å¿œï¼‰
            const logMin = Math.log10(Math.max(minFieldStrength, 0.001));
            const logMax = Math.log10(Math.max(maxFieldStrength, 0.001));

            // é‡åŠ›å ´ã‚’æç”»
            for (let i = 0; i < gravityFieldResolution; i++) {
                for (let j = 0; j < gravityFieldResolution; j++) {
                    const x = i * stepX;
                    const y = j * stepY;
                    const fieldStrength = fieldStrengths[i][j];

                    // â˜… å¤‰æ›´ï¼šå¯¾æ•°ã‚¹ã‚±ãƒ¼ãƒ«ã§æ­£è¦åŒ–
                    let normalizedStrength = 0;
                    if (fieldStrength > 0.001 && logMax !== logMin) {
                        const logValue = Math.log10(fieldStrength);
                        normalizedStrength = (logValue - logMin) / (logMax - logMin);
                        normalizedStrength = Math.max(0, Math.min(1, normalizedStrength));
                    }

                    // â˜… å¤‰æ›´ï¼šã‚ˆã‚Šé®®æ˜ãªè‰²ãƒãƒƒãƒ”ãƒ³ã‚°
                    const color = getEnhancedHeatmapColor(normalizedStrength, fieldStrength);

                    gravityFieldCtx.fillStyle = color;
                    gravityFieldCtx.fillRect(x, y, stepX + 1, stepY + 1);
                }
            }
        }

        // â˜… å¤‰æ›´ï¼šé‡åŠ›å ´å¼·åº¦è¨ˆç®—ï¼ˆãƒãƒ†ãƒ³ã‚·ãƒ£ãƒ«ã‹ã‚‰é‡åŠ›åŠ é€Ÿåº¦ã¸ï¼‰
        function calculateGravityFieldStrength(x, y) {
            let totalFieldStrength = 0;
            const G = gravity * 50;

            for (let body of bodies) {
                if (!body.isValid) continue;

                const dx = x - body.x;
                const dy = y - body.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                // â˜… å¤‰æ›´ï¼šæœ€å°è·é›¢ã‚’å¤©ä½“ã®åŠå¾„ã«åŸºã¥ã„ã¦è¨­å®š
                const bodyRadius = Math.sqrt(body.mass) * 1.5;
                const safeDistance = Math.max(distance, bodyRadius * 0.5);

                // â˜… å¤‰æ›´ï¼šãƒ–ãƒ©ãƒƒã‚¯ãƒ›ãƒ¼ãƒ«ã®æ½®æ±åŠ›ã‚’ç¾å®Ÿçš„ã«è¡¨ç¾
                let effectiveG = G;
                let massMultiplier = 1;

                if (body.isBlackHole) {
                    effectiveG *= BLACK_HOLE_GRAVITY_MULTIPLIER;
                    // ãƒ–ãƒ©ãƒƒã‚¯ãƒ›ãƒ¼ãƒ«ã®äº‹è±¡ã®åœ°å¹³ç·šå†…ã§ã¯æ¥µç«¯ã«å¼·ã„é‡åŠ›å ´
                    if (distance < body.eventHorizonRadius) {
                        massMultiplier = 10; // äº‹è±¡ã®åœ°å¹³ç·šå†…ã§ã¯é‡åŠ›å ´ã‚’10å€ã«
                    } else if (distance < body.eventHorizonRadius * 2) {
                        // äº‹è±¡ã®åœ°å¹³ç·šå‘¨è¾ºã§ã®æ€¥æ¿€ãªé‡åŠ›å‹¾é…
                        const ratio = distance / body.eventHorizonRadius;
                        massMultiplier = 1 + 9 * Math.exp(-(ratio - 1) * 3);
                    }
                }

                // é‡åŠ›åŠ é€Ÿåº¦ã®å¤§ãã•: a = GM/rÂ²
                const fieldStrength = (effectiveG * body.mass * massMultiplier) / (safeDistance * safeDistance);
                totalFieldStrength += fieldStrength;
            }

            return totalFieldStrength;
        }

        // â˜… å¤‰æ›´ï¼šå¼·åŒ–ã•ã‚ŒãŸãƒ’ãƒ¼ãƒˆãƒãƒƒãƒ—è‰²è¨ˆç®—
        function getEnhancedHeatmapColor(value, rawFieldStrength) {
            // 0-1ã®å€¤ã‚’ã‚ˆã‚Šé®®æ˜ãªè‰²ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ã«å¤‰æ›
            value = Math.max(0, Math.min(1, value));

            let r, g, b, alpha;

            // â˜… å¤‰æ›´ï¼šã‚ˆã‚Šå¤šæ®µéšã®è‰²å¤‰åŒ–ã§é‡åŠ›å ´ã®å¼·åº¦ã‚’è¡¨ç¾
            if (value < 0.1) {
                // æ¥µå¼±ã„é‡åŠ›å ´ï¼šé€æ˜ã«è¿‘ã„ç´«
                const t = value / 0.1;
                r = Math.floor(t * 50);
                g = 0;
                b = Math.floor(t * 100);
                alpha = t * 0.1;
            } else if (value < 0.3) {
                // å¼±ã„é‡åŠ›å ´ï¼šç´«â†’é’
                const t = (value - 0.1) / 0.2;
                r = Math.floor(50 + t * 50);
                g = Math.floor(t * 100);
                b = Math.floor(100 + t * 155);
                alpha = 0.1 + t * 0.15;
            } else if (value < 0.5) {
                // ä¸­ç¨‹åº¦ã®é‡åŠ›å ´ï¼šé’â†’æ°´è‰²
                const t = (value - 0.3) / 0.2;
                r = Math.floor(100 - t * 100);
                g = Math.floor(100 + t * 155);
                b = 255;
                alpha = 0.25 + t * 0.15;
            } else if (value < 0.7) {
                // å¼·ã„é‡åŠ›å ´ï¼šæ°´è‰²â†’ç·‘
                const t = (value - 0.5) / 0.2;
                r = 0;
                g = 255;
                b = Math.floor(255 - t * 255);
                alpha = 0.4 + t * 0.15;
            } else if (value < 0.85) {
                // éå¸¸ã«å¼·ã„é‡åŠ›å ´ï¼šç·‘â†’é»„
                const t = (value - 0.7) / 0.15;
                r = Math.floor(t * 255);
                g = 255;
                b = 0;
                alpha = 0.55 + t * 0.15;
            } else if (value < 0.95) {
                // æ¥µå¼·ã„é‡åŠ›å ´ï¼šé»„â†’ã‚ªãƒ¬ãƒ³ã‚¸
                const t = (value - 0.85) / 0.1;
                r = 255;
                g = Math.floor(255 - t * 100);
                b = 0;
                alpha = 0.7 + t * 0.15;
            } else {
                // ãƒ–ãƒ©ãƒƒã‚¯ãƒ›ãƒ¼ãƒ«ç´šã®é‡åŠ›å ´ï¼šã‚ªãƒ¬ãƒ³ã‚¸â†’èµ¤â†’ç™½
                const t = (value - 0.95) / 0.05;
                r = 255;
                g = Math.floor(155 * (1 - t) + 255 * t);
                b = Math.floor(255 * t);
                alpha = 0.85 + t * 0.15;
            }

            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }

        // â˜… è¿½åŠ ï¼šé‡åŠ›ãƒãƒ†ãƒ³ã‚·ãƒ£ãƒ«è¨ˆç®—ï¼ˆæ—¢å­˜ã®é–¢æ•°ã‚’ç¶­æŒã€ã‚¨ãƒãƒ«ã‚®ãƒ¼è¨ˆç®—ã§ä½¿ç”¨ï¼‰
        function calculateGravityPotential(x, y) {
            let potential = 0;
            const G = gravity * 50;

            for (let body of bodies) {
                if (!body.isValid) continue;

                const dx = x - body.x;
                const dy = y - body.y;
                const distance = Math.sqrt(dx * dx + dy * dy) + 10; // ã‚¼ãƒ­é™¤ç®—é˜²æ­¢

                // ãƒ–ãƒ©ãƒƒã‚¯ãƒ›ãƒ¼ãƒ«ã®é‡åŠ›ã‚’è€ƒæ…®
                let effectiveG = G;
                if (body.isBlackHole) {
                    effectiveG *= BLACK_HOLE_GRAVITY_MULTIPLIER;
                }

                potential -= (effectiveG * body.mass) / distance;
            }

            return potential;
        }

        /**
         * ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚µã‚¤ã‚ºè¨­å®š
         */
        function resizeCanvas() {
            try {
                const container = canvas.parentElement;
                const newWidth = container.clientWidth;
                const newHeight = container.clientHeight;

                if (canvas.width !== newWidth || canvas.height !== newHeight) {
                    canvas.width = newWidth;
                    canvas.height = newHeight;
                    generateStars(); // ã‚µã‚¤ã‚ºå¤‰æ›´æ™‚ã«æ˜Ÿã‚’å†ç”Ÿæˆ

                    // â˜… è¿½åŠ ï¼šé‡åŠ›å ´ã‚­ãƒ£ãƒ³ãƒã‚¹ã®ãƒªã‚µã‚¤ã‚º
                    setupGravityFieldCanvas();
                }
            } catch (error) {
                console.warn('Canvas resize error:', error);
            }
        }

        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        /**
         * æ˜Ÿã®èƒŒæ™¯ç”Ÿæˆï¼ˆæœ€é©åŒ–ï¼‰
         */
        function generateStars() {
            stars = [];
            const starCount = Math.min(150, Math.floor((canvas.width * canvas.height) / 8000));

            for (let i = 0; i < starCount; i++) {
                stars.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    size: Math.random() * 2 + 0.5,
                    opacity: Math.random() * 0.8 + 0.2,
                    twinkle: Math.random() * Math.PI * 2
                });
            }
            backgroundGenerated = true;
        }

        /**
         * ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚¯ãƒ©ã‚¹
         */
        class Particle {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 2;
                this.vy = (Math.random() - 0.5) * 2;
                this.life = 1.0;
                this.decay = 0.02 + Math.random() * 0.02;
                this.size = Math.random() * 3 + 1;
                this.color = color;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.life -= this.decay;
                this.vx *= 0.98;
                this.vy *= 0.98;
            }

            draw() {
                if (this.life <= 0) return;

                ctx.save();
                ctx.globalAlpha = this.life * 0.6;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size * this.life, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }

            isDead() {
                return this.life <= 0;
            }
        }

        /**
         * å¤©ä½“ã‚¯ãƒ©ã‚¹
         */
        class Body {
            constructor(x, y, vx = 0, vy = 0, mass = 25) {
                // â˜… åŸºæœ¬ç‰©ç†ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
                this.x = x;                                        // Xåº§æ¨™ä½ç½®
                this.y = y;                                        // Yåº§æ¨™ä½ç½®
                this.vx = vx;                                      // Xæ–¹å‘é€Ÿåº¦
                this.vy = vy;                                      // Yæ–¹å‘é€Ÿåº¦
                this.mass = Math.max(10, Math.min(400, mass));     // è³ªé‡ï¼ˆ10-400ã®ç¯„å›²ï¼‰

                // â˜… è¦–è¦šåŠ¹æœãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
                this.trail = [];                                   // è»Œè·¡åº§æ¨™ã®é…åˆ—
                this.color = this.generateColor();                 // å¤©ä½“ã®è‰²

                // â˜… ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³åˆ¶å¾¡ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
                this.trailUpdateCounter = 0;                       // è»Œè·¡æ›´æ–°ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼
                this.isValid = true;                               // å¤©ä½“ãŒæœ‰åŠ¹ã‹ã©ã†ã‹ã®ãƒ•ãƒ©ã‚°
                this.pulsePhase = Math.random() * Math.PI * 2;     // è„ˆå‹•åŠ¹æœã®ä½ç›¸
                this.particleTimer = 0;                            // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ç”Ÿæˆã‚¿ã‚¤ãƒãƒ¼

                // â˜… å¤©ä½“ã‚¿ã‚¤ãƒ—åˆ¥ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
                this.type = this.determineBodyType();              // å¤©ä½“ç¨®åˆ¥ï¼ˆnormal, whiteDwarf, neutronStarç­‰ï¼‰
                this.rotation = 0;                                 // å›è»¢è§’åº¦
                this.temperature = 1.0;                            // æ¸©åº¦ä¿‚æ•°ï¼ˆç™½è‰²çŸ®æ˜Ÿç”¨ï¼‰
                this.magneticField = 0;                            // ç£å ´å¼·åº¦ï¼ˆä¸­æ€§å­æ˜Ÿãƒ»ãƒ‘ãƒ«ã‚µãƒ¼ç”¨ï¼‰
                this.beamRotation = 0;                             // ãƒ“ãƒ¼ãƒ å›è»¢è§’åº¦ï¼ˆãƒ‘ãƒ«ã‚µãƒ¼ç”¨ï¼‰
                this.planets = [];                                 // æƒ‘æ˜Ÿé…åˆ—ï¼ˆæƒ‘æ˜Ÿç³»ç”¨ï¼‰

                // â˜… ãƒ–ãƒ©ãƒƒã‚¯ãƒ›ãƒ¼ãƒ«å°‚ç”¨ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
                this.isBlackHole = this.type === 'blackHole';      // ãƒ–ãƒ©ãƒƒã‚¯ãƒ›ãƒ¼ãƒ«ãƒ•ãƒ©ã‚°
                this.blackHoleRotation = 0;                        // ãƒ–ãƒ©ãƒƒã‚¯ãƒ›ãƒ¼ãƒ«å›è»¢è§’åº¦
                this.eventHorizonRadius = 0;                       // äº‹è±¡ã®åœ°å¹³ç·šåŠå¾„

                // â˜… ãƒ‘ãƒ«ã‚µãƒ¼å°‚ç”¨ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
                this.pulsarAge = 0;                                // ãƒ‘ãƒ«ã‚µãƒ¼å¹´é½¢ï¼ˆæ™‚é–“çµŒéï¼‰
                this.rotationPeriod = 0.001;                       // å›è»¢å‘¨æœŸï¼ˆç§’ï¼‰
                this.lastCollisionTime = 0;                        // æœ€å¾Œã®è¡çªæ™‚åˆ»

                // åˆæœŸåŒ–å®Œäº†
                this.initializeByType();
            }

            // â˜… ä¿®æ­£ï¼šå¤©ä½“ã‚¿ã‚¤ãƒ—åˆ¤å®šãƒ­ã‚¸ãƒƒã‚¯ã‚’ç‰©ç†çš„ã«æ­£ã—ã
            determineBodyType() {
                if (this.mass >= BLACK_HOLE_MASS_THRESHOLD) {
                    return 'blackHole';
                } else if (this.mass >= PLANET_SYSTEM_MASS_THRESHOLD) {
                    return 'planetSystem';
                } else if (this.mass >= NEUTRON_STAR_MASS_THRESHOLD) {
                    // â˜… ä¿®æ­£ï¼šãƒ‘ãƒ«ã‚µãƒ¼ã¯è‹¥ã„ä¸­æ€§å­æ˜Ÿã®ç‰¹æ®ŠçŠ¶æ…‹
                    // æ—¢å­˜ã®ãƒ‘ãƒ«ã‚µãƒ¼ã¯ç£å ´æ¸›è¡°ã§ä¸­æ€§å­æ˜Ÿã«é€²åŒ–ã™ã‚‹å¯èƒ½æ€§
                    if (this.type === 'pulsar') {
                        // ãƒ‘ãƒ«ã‚µãƒ¼ã®ç£å ´æ¸›è¡°ãƒã‚§ãƒƒã‚¯ï¼ˆæ™‚é–“çµŒéã§ä¸­æ€§å­æ˜Ÿã«ãªã‚‹ï¼‰
                        return this.shouldPulsarDecay() ? 'neutronStar' : 'pulsar';
                    }
                    // æ–°è¦ç”Ÿæˆæ™‚ï¼š10%ã®ç¢ºç‡ã§ãƒ‘ãƒ«ã‚µãƒ¼ï¼ˆè‹¥ã„ä¸­æ€§å­æ˜Ÿï¼‰
                    return Math.random() < 0.1 ? 'pulsar' : 'neutronStar';
                } else if (this.mass >= PULSAR_MASS_THRESHOLD) {
                    // â˜… ä¿®æ­£ï¼šã“ã®è³ªé‡ç¯„å›²ã§ã¯ä¸­æ€§å­æ˜Ÿå‰é§†ä½“
                    // æ¿€ã—ã„è¡çªã‚„å›è»¢ã‚¨ãƒãƒ«ã‚®ãƒ¼ãŒã‚ã‚‹å ´åˆã®ã¿ãƒ‘ãƒ«ã‚µãƒ¼åŒ–
                    if (this.hasHighRotationalEnergy()) {
                        return 'pulsar';
                    }
                    return 'neutronStar';
                } else if (this.mass >= WHITE_DWARF_MASS_THRESHOLD) {
                    return 'whiteDwarf';
                } else {
                    return 'normal';
                }
            }

            // â˜… è¿½åŠ ï¼šãƒ‘ãƒ«ã‚µãƒ¼ã®ç£å ´æ¸›è¡°åˆ¤å®š
            shouldPulsarDecay() {
                // å¹´é½¢ï¼ˆæ™‚é–“çµŒéï¼‰ã¨ç£å ´å¼·åº¦ã«åŸºã¥ãæ¸›è¡°
                if (!this.pulsarAge) this.pulsarAge = 0;
                this.pulsarAge += 1;

                // ç£å ´å¼·åº¦ã®æ¸›è¡°ï¼ˆæ™‚é–“ã¨å…±ã«æ¸›å°‘ï¼‰
                this.magneticField = Math.max(0.1, this.magneticField - 0.0001);

                // ç£å ´ãŒå¼±ããªã‚‹ã¨é€šå¸¸ã®ä¸­æ€§å­æ˜Ÿã«ãªã‚‹
                // ã¾ãŸã€ä¸€å®šç¢ºç‡ã§ç£å ´ãŒå®Œå…¨ã«æ¸›è¡°
                return this.magneticField < 0.5 || (this.pulsarAge > 500 && Math.random() < 0.001);
            }

            // â˜… è¿½åŠ ï¼šé«˜å›è»¢ã‚¨ãƒãƒ«ã‚®ãƒ¼åˆ¤å®š
            hasHighRotationalEnergy() {
                // é€Ÿåº¦ï¼ˆå›è»¢ã«ç›¸å½“ï¼‰ãŒé«˜ã„å ´åˆã«ãƒ‘ãƒ«ã‚µãƒ¼åŒ–ã—ã‚„ã™ã„
                const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
                const rotationalThreshold = 100; // é«˜é€Ÿåº¦é–¾å€¤

                // æœ€è¿‘è¡çªã—ãŸå ´åˆï¼ˆè³ªé‡ãŒæ€¥æ¿€ã«å¢—åŠ ã—ãŸå ´åˆï¼‰
                const recentCollision = this.lastCollisionTime && (time - this.lastCollisionTime) < 100;

                return speed > rotationalThreshold || recentCollision;
            }

            // â˜… ä¿®æ­£ï¼šã‚¿ã‚¤ãƒ—åˆ¥åˆæœŸåŒ–
            initializeByType() {
                switch (this.type) {
                    case 'blackHole':
                        this.becomeBlackHole();
                        break;
                    case 'neutronStar':
                        this.color = '#E6E6FA'; // è–„ç´«
                        this.magneticField = 0.3 + Math.random() * 0.4; // â˜… ä¿®æ­£ï¼šå¼±ã„ç£å ´
                        this.rotation = 0;
                        break;
                    case 'whiteDwarf':
                        this.color = '#F0F8FF'; // ã‚¢ãƒªã‚¹ãƒ–ãƒ«ãƒ¼
                        this.temperature = 2.0; // é«˜æ¸©ã‹ã‚‰é–‹å§‹
                        break;
                    case 'pulsar':
                        this.color = '#00FFFF'; // ã‚·ã‚¢ãƒ³
                        this.magneticField = 1.2 + Math.random() * 0.6; // â˜… ä¿®æ­£ï¼šå¼·ã„ç£å ´
                        this.beamRotation = 0;
                        this.pulsarAge = 0; // â˜… è¿½åŠ ï¼šãƒ‘ãƒ«ã‚µãƒ¼å¹´é½¢åˆæœŸåŒ–
                        this.rotationPeriod = 0.001 + Math.random() * 0.1; // â˜… è¿½åŠ ï¼šå›è»¢å‘¨æœŸï¼ˆçŸ­ã„ï¼‰
                        console.log(`ãƒ‘ãƒ«ã‚µãƒ¼èª•ç”Ÿ: è³ªé‡ ${this.mass.toFixed(1)}, ç£å ´å¼·åº¦ ${this.magneticField.toFixed(2)}, å›è»¢å‘¨æœŸ ${this.rotationPeriod.toFixed(3)}s`);
                        break;
                    case 'planetSystem':
                        this.color = '#FFD700'; // ã‚´ãƒ¼ãƒ«ãƒ‰ï¼ˆæ’æ˜Ÿï¼‰
                        this.generatePlanets();
                        break;
                    default:
                        // é€šå¸¸æ˜Ÿã®è‰²ã‚’å†ç”Ÿæˆ
                        if (!this.color || this.type === 'normal') {
                            this.color = this.generateColor();
                        }
                        break;
                }
            }

            // â˜… è¿½åŠ ï¼šãƒ–ãƒ©ãƒƒã‚¯ãƒ›ãƒ¼ãƒ«åŒ–å‡¦ç†
            becomeBlackHole() {
                this.isBlackHole = true;
                this.color = '#000000'; // é»’è‰²ã«å¤‰æ›´
                this.eventHorizonRadius = Math.sqrt(this.mass) * 2;
                console.log(`ãƒ–ãƒ©ãƒƒã‚¯ãƒ›ãƒ¼ãƒ«èª•ç”Ÿï¼è³ªé‡: ${this.mass.toFixed(1)}`);

                // ãƒ–ãƒ©ãƒƒã‚¯ãƒ›ãƒ¼ãƒ«èª•ç”Ÿã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
                this.createBlackHoleBirthEffect();
            }

            // â˜… è¿½åŠ ï¼šãƒ–ãƒ©ãƒƒã‚¯ãƒ›ãƒ¼ãƒ«èª•ç”Ÿã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
            createBlackHoleBirthEffect() {
                for (let i = 0; i < 50; i++) {
                    const angle = (Math.PI * 2 * i) / 50;
                    const speed = 5 + Math.random() * 8;
                    const distance = 20 + Math.random() * 30;
                    const px = this.x + Math.cos(angle) * distance;
                    const py = this.y + Math.sin(angle) * distance;

                    const particle = new Particle(px, py, '#ffffff');
                    particle.vx = Math.cos(angle) * speed;
                    particle.vy = Math.sin(angle) * speed;
                    particle.life = 2.0;
                    particle.size = 3 + Math.random() * 4;
                    particles.push(particle);
                }
            }

            // â˜… è¿½åŠ ï¼šæƒ‘æ˜Ÿç³»ã®æƒ‘æ˜Ÿç”Ÿæˆ
            generatePlanets() {
                const planetCount = 2 + Math.floor(Math.random() * 4); // 2-5å€‹ã®æƒ‘æ˜Ÿ
                for (let i = 0; i < planetCount; i++) {
                    const distance = 30 + i * 25 + Math.random() * 20;
                    const angle = Math.random() * Math.PI * 2;
                    const speed = Math.sqrt(this.mass * 0.5 / distance); // ã‚±ãƒ—ãƒ©ãƒ¼ã®æ³•å‰‡ã«åŸºã¥ãè»Œé“é€Ÿåº¦

                    this.planets.push({
                        distance: distance,
                        angle: angle,
                        speed: speed * (0.8 + Math.random() * 0.4), // é€Ÿåº¦ã«ãƒãƒªã‚¨ãƒ¼ã‚·ãƒ§ãƒ³
                        size: 1 + Math.random() * 3,
                        color: this.generatePlanetColor()
                    });
                }
            }

            // â˜… è¿½åŠ ï¼šæƒ‘æ˜Ÿã®è‰²ç”Ÿæˆï¼ˆå…ƒã®generatePlanetColorã‚’æ®‹ã™ï¼‰
            generatePlanetColor() {
                const planetColors = [
                    '#8B4513', '#CD853F', '#DEB887', '#F4A460',
                    '#4169E1', '#1E90FF', '#87CEEB', '#B0E0E6',
                    '#FF6347', '#FF4500', '#DC143C', '#B22222'
                ];
                return planetColors[Math.floor(Math.random() * planetColors.length)];
            }

            // â˜… ä¿®æ­£ï¼šé€šå¸¸æ˜Ÿã®è‰²ç”Ÿæˆ
            generateColor() {
                const colors = [
                    '#ff6b6b', '#4ecdc4', '#45b7d1', '#f9ca24',
                    '#f0932b', '#eb4d4b', '#6c5ce7', '#a29bfe',
                    '#fd79a8', '#fdcb6e', '#00b894', '#e17055',
                    '#74b9ff', '#0984e3', '#00cec9', '#e84393'
                ];
                return colors[Math.floor(Math.random() * colors.length)];
            }

            /**
             * å¤©ä½“ã®ä½ç½®ãƒ»é€Ÿåº¦æ›´æ–°
             */
            update(dt) {
                try {
                    // å¤©ä½“ã‚¿ã‚¤ãƒ—å¤‰åŒ–ãƒã‚§ãƒƒã‚¯
                    const newType = this.determineBodyType();
                    if (newType !== this.type && this.shouldEvolve(newType)) {
                        const oldType = this.type;
                        this.type = newType;
                        this.initializeByType();
                        console.log(`å¤©ä½“é€²åŒ–: ${this.getTypeNameJapanese(oldType)} â†’ ${this.getTypeNameJapanese()} (è³ªé‡: ${this.mass.toFixed(1)})`);
                    }

                    // ã‚¿ã‚¤ãƒ—åˆ¥æ›´æ–°å‡¦ç†
                    this.updateByType(dt);

                    // è»Œé“è¨˜éŒ²ï¼ˆãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–ï¼‰
                    this.trailUpdateCounter++;
                    if (this.trailUpdateCounter % 3 === 0 && showTrails) {
                        this.trail.push({ x: this.x, y: this.y });
                        if (this.trail.length > trailLength) {
                            this.trail.shift();
                        }
                    }

                    // ä½ç½®æ›´æ–°
                    this.x += this.vx * dt;
                    this.y += this.vy * dt;

                    // â˜… ä¿®æ­£ï¼šå¢ƒç•Œæ¡ä»¶å‡¦ç†ã‚’æ”¹å–„
                    this.handleBoundaryConditions();

                    // è„ˆå‹•åŠ¹æœã®æ›´æ–°
                    this.pulsePhase += 0.05;

                    // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ç”Ÿæˆ
                    this.particleTimer++;
                    this.generateParticlesByType();

                    // ç•°å¸¸å€¤ãƒã‚§ãƒƒã‚¯
                    if (!this.isValidState()) {
                        this.isValid = false;
                        throw new Error('Invalid body state detected');
                    }

                } catch (error) {
                    console.warn('Body update error:', error);
                    this.isValid = false;
                }
            }

            // â˜… è¿½åŠ ï¼šå¢ƒç•Œæ¡ä»¶å‡¦ç†ã‚’ç‹¬ç«‹ã—ãŸãƒ¡ã‚½ãƒƒãƒ‰ã«
            handleBoundaryConditions() {
                const margin = 30;
                const damping = 0.8;

                if (this.x < margin) {
                    this.x = margin;
                    this.vx = Math.abs(this.vx) * damping;
                } else if (this.x > canvas.width - margin) {
                    this.x = canvas.width - margin;
                    this.vx = -Math.abs(this.vx) * damping;
                }

                if (this.y < margin) {
                    this.y = margin;
                    this.vy = Math.abs(this.vy) * damping;
                } else if (this.y > canvas.height - margin) {
                    this.y = canvas.height - margin;
                    this.vy = -Math.abs(this.vy) * damping;
                }
            }

            // â˜… è¿½åŠ ï¼šå¤©ä½“çŠ¶æ…‹ã®æœ‰åŠ¹æ€§ãƒã‚§ãƒƒã‚¯
            isValidState() {
                return isFinite(this.x) && isFinite(this.y) &&
                    isFinite(this.vx) && isFinite(this.vy) &&
                    this.mass > 0;
            }

            // â˜… ä¿®æ­£ï¼šé€²åŒ–æ¡ä»¶ã‚’ç°¡æ½”ã«
            shouldEvolve(newType) {
                // ãƒ–ãƒ©ãƒƒã‚¯ãƒ›ãƒ¼ãƒ«ã¯ä¸å¯é€†
                if (this.type === 'blackHole') return false;

                // ã‚ˆã‚Šé‡ã„ã‚¿ã‚¤ãƒ—ã¸ã®é€²åŒ–ã®ã¿è¨±å¯
                const typeOrder = ['normal', 'whiteDwarf', 'pulsar', 'neutronStar', 'planetSystem', 'blackHole'];
                const currentIndex = typeOrder.indexOf(this.type);
                const newIndex = typeOrder.indexOf(newType);

                return newIndex > currentIndex || newType === 'blackHole';
            }

            // â˜… è¿½åŠ ï¼šã‚¿ã‚¤ãƒ—åˆ¥æ›´æ–°å‡¦ç†
            updateByType(dt) {
                switch (this.type) {
                    case 'blackHole':
                        this.blackHoleRotation += 0.02;
                        this.eventHorizonRadius = Math.sqrt(this.mass) * 2;
                        break;
                    case 'neutronStar':
                        this.rotation += 0.05; // â˜… ä¿®æ­£ï¼šä¸­æ€§å­æ˜Ÿã®å›è»¢ã¯é…ã‚
                        // ç£å ´ã®ç·©ã‚„ã‹ãªæ¸›è¡°
                        this.magneticField = Math.max(0.1, this.magneticField - 0.00001);
                        break;
                    case 'whiteDwarf':
                        this.temperature = Math.max(0.2, this.temperature - 0.0001);
                        break;
                    case 'pulsar':
                        // â˜… ä¿®æ­£ï¼šãƒ‘ãƒ«ã‚µãƒ¼ã®ç‰©ç†çš„ç‰¹æ€§ã‚’æ­£ç¢ºã«
                        // æ¥µã‚ã¦é«˜é€Ÿå›è»¢ï¼ˆãƒŸãƒªç§’ãƒ‘ãƒ«ã‚µãƒ¼ã®å ´åˆï¼‰
                        this.beamRotation += this.rotationPeriod > 0.01 ? 0.2 : 0.5; // çŸ­å‘¨æœŸã»ã©é«˜é€Ÿå›è»¢
                        this.rotation += 0.15;

                        // ç£å ´ã¨ã‚¹ãƒ”ãƒ³ã®ç›¸äº’ä½œç”¨
                        if (this.magneticField > 1.0) {
                            // å¼·ç£å ´ã«ã‚ˆã‚‹åˆ¶å‹•åŠ¹æœï¼ˆå›è»¢æ¸›é€Ÿï¼‰
                            this.rotationPeriod += 0.00001;
                        }

                        // ãƒ‘ãƒ«ã‚µãƒ¼å¹´é½¢ã®æ›´æ–°
                        if (!this.pulsarAge) this.pulsarAge = 0;
                        this.pulsarAge += dt;
                        break;
                    case 'planetSystem':
                        this.planets.forEach(planet => {
                            planet.angle += planet.speed * dt;
                        });
                        break;
                }
            }

            // â˜… è¿½åŠ ï¼šã‚¿ã‚¤ãƒ—åˆ¥ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ç”Ÿæˆ
            generateParticlesByType() {
                const baseInterval = 15;
                const intervals = {
                    'blackHole': 8,
                    'neutronStar': 25,  // â˜… ä¿®æ­£ï¼šé »åº¦ã‚’ä¸‹ã’ã‚‹
                    'pulsar': 10,       // â˜… ä¿®æ­£ï¼šé »åº¦ã‚’ä¸‹ã’ã‚‹
                    'planetSystem': 40, // â˜… ä¿®æ­£ï¼šé »åº¦ã‚’ä¸‹ã’ã‚‹
                    'default': baseInterval
                };

                const interval = intervals[this.type] || intervals.default;

                if (this.particleTimer % interval !== 0) return;

                switch (this.type) {
                    case 'blackHole':
                        this.createAccretionDiskParticle();
                        break;
                    case 'neutronStar':
                        this.createMagneticFieldParticle();
                        break;
                    case 'pulsar':
                        this.createPulsarBeamParticle();
                        break;
                    case 'planetSystem':
                        this.createSolarWindParticle();
                        break;
                    default:
                        if (Math.random() < 0.3) {
                            this.createDefaultParticle();
                        }
                        break;
                }
            }

            // â˜… è¿½åŠ ï¼šãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ç”Ÿæˆã‚’ç‹¬ç«‹åŒ–
            createDefaultParticle() {
                const radius = Math.sqrt(this.mass) * 1.5;
                const angle = Math.random() * Math.PI * 2;
                const distance = radius + Math.random() * 10;
                const px = this.x + Math.cos(angle) * distance;
                const py = this.y + Math.sin(angle) * distance;
                particles.push(new Particle(px, py, this.color));
            }

            // â˜… ä¿®æ­£ï¼šæ—¥æœ¬èªã‚¿ã‚¤ãƒ—åå–å¾—ï¼ˆå¼•æ•°ã§ã‚¿ã‚¤ãƒ—æŒ‡å®šå¯èƒ½ï¼‰
            getTypeNameJapanese(type = this.type) {
                const typeNames = {
                    'normal': 'é€šå¸¸æ˜Ÿ',
                    'whiteDwarf': 'ç™½è‰²çŸ®æ˜Ÿ',
                    'neutronStar': 'ä¸­æ€§å­æ˜Ÿ',
                    'pulsar': 'ãƒ‘ãƒ«ã‚µãƒ¼',
                    'planetSystem': 'æƒ‘æ˜Ÿç³»',
                    'blackHole': 'ãƒ–ãƒ©ãƒƒã‚¯ãƒ›ãƒ¼ãƒ«'
                };
                return typeNames[type] || 'ä¸æ˜';
            }

            // â˜… è¿½åŠ ï¼šé™ç€å††ç›¤ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ç”Ÿæˆ
            createAccretionDiskParticle() {
                const angle = Math.random() * Math.PI * 2;
                const radius = this.eventHorizonRadius * (2 + Math.random() * 3);
                const px = this.x + Math.cos(angle) * radius;
                const py = this.y + Math.sin(angle) * radius;

                // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚’ä¸­å¿ƒã«å‘ã‹ã£ã¦èºæ—‹çŠ¶ã«ç§»å‹•
                const particle = new Particle(px, py, '#ff6b00');
                const spiralSpeed = 0.5;
                particle.vx = -Math.cos(angle) * spiralSpeed + Math.sin(angle) * spiralSpeed * 0.3;
                particle.vy = -Math.sin(angle) * spiralSpeed - Math.cos(angle) * spiralSpeed * 0.3;
                particle.life = 3.0;
                particle.size = 1 + Math.random() * 2;
                particles.push(particle);
            }
            // â˜… è¿½åŠ ï¼šä¸­æ€§å­æ˜Ÿã®ç£å ´ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«
            createMagneticFieldParticle() {
                const angle = this.rotation + Math.random() * Math.PI * 0.5;
                const radius = Math.sqrt(this.mass) * 2;
                const distance = radius + Math.random() * 20;
                const px = this.x + Math.cos(angle) * distance;
                const py = this.y + Math.sin(angle) * distance;

                const particle = new Particle(px, py, '#9370DB');
                particle.vx = Math.cos(angle + Math.PI / 2) * 2;
                particle.vy = Math.sin(angle + Math.PI / 2) * 2;
                particle.life = 2.0;
                particle.size = 1;
                particles.push(particle);
            }

            // â˜… è¿½åŠ ï¼šãƒ‘ãƒ«ã‚µãƒ¼ã®ãƒ“ãƒ¼ãƒ ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«
            createPulsarBeamParticle() {
                // 2ã¤ã®å¯¾å‘ã™ã‚‹ãƒ“ãƒ¼ãƒ 
                for (let beam = 0; beam < 2; beam++) {
                    const beamAngle = this.beamRotation + beam * Math.PI;
                    const distance = 20 + Math.random() * 100;
                    const px = this.x + Math.cos(beamAngle) * distance;
                    const py = this.y + Math.sin(beamAngle) * distance;

                    const particle = new Particle(px, py, '#00FFFF');
                    particle.vx = Math.cos(beamAngle) * 5;
                    particle.vy = Math.sin(beamAngle) * 5;
                    particle.life = 1.5;
                    particle.size = 2;
                    particles.push(particle);
                }
            }

            // â˜… è¿½åŠ ï¼šæ’æ˜Ÿã®å¤ªé™½é¢¨ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«
            createSolarWindParticle() {
                const angle = Math.random() * Math.PI * 2;
                const radius = Math.sqrt(this.mass) * 1.5;
                const distance = radius + Math.random() * 15;
                const px = this.x + Math.cos(angle) * distance;
                const py = this.y + Math.sin(angle) * distance;

                const particle = new Particle(px, py, '#FFA500');
                particle.vx = Math.cos(angle) * (1 + Math.random() * 2);
                particle.vy = Math.sin(angle) * (1 + Math.random() * 2);
                particle.life = 3.0;
                particle.size = 1;
                particles.push(particle);
            }

            /**
             * å¤©ä½“ã®æç”»ï¼ˆç¥ç§˜çš„ã«æ”¹è‰¯ï¼‰
             */
            draw() {
                if (!this.isValid) return;

                try {
                    // â˜… ä¿®æ­£ï¼šè»Œé“æç”»ã‚’ãªã‚ã‚‰ã‹ãªãƒ™ã‚¸ã‚§æ›²ç·šã§æ”¹è‰¯
                    if (showTrails && this.trail.length > 3) {
                        ctx.lineCap = 'round';
                        ctx.lineJoin = 'round';

                        // â˜… è¿½åŠ ï¼šãªã‚ã‚‰ã‹ãªãƒ™ã‚¸ã‚§æ›²ç·šã«ã‚ˆã‚‹è»Œè·¡æç”»
                        for (let i = 2; i < this.trail.length - 1; i++) {
                            const alpha = (i / this.trail.length) * 0.8;
                            const width = (i / this.trail.length) * 4 + 0.5;

                            // åˆ¶å¾¡ç‚¹ã®è¨ˆç®—ï¼ˆã‚«ãƒˆãƒãƒ«ãƒ»ãƒ­ãƒ  ã‚¹ãƒ—ãƒ©ã‚¤ãƒ³ï¼‰
                            const p0 = this.trail[i - 2];
                            const p1 = this.trail[i - 1];
                            const p2 = this.trail[i];
                            const p3 = this.trail[i + 1] || this.trail[i];

                            // â˜… è¿½åŠ ï¼šãªã‚ã‚‰ã‹ãªã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³è»Œé“
                            const gradient = ctx.createLinearGradient(
                                p1.x, p1.y, p2.x, p2.y
                            );

                            const alphaHex = Math.floor(alpha * 255).toString(16).padStart(2, '0');
                            const prevAlphaHex = Math.floor(((i - 1) / this.trail.length) * 255).toString(16).padStart(2, '0');

                            gradient.addColorStop(0, this.color + prevAlphaHex);
                            gradient.addColorStop(1, this.color + alphaHex);

                            ctx.strokeStyle = gradient;
                            ctx.lineWidth = width;

                            // â˜… è¿½åŠ ï¼šãƒ™ã‚¸ã‚§æ›²ç·šã§ã®æç”»
                            ctx.beginPath();
                            ctx.moveTo(p1.x, p1.y);

                            // åˆ¶å¾¡ç‚¹ã®è¨ˆç®—ï¼ˆå¹³æ»‘åŒ–ï¼‰
                            const tension = 0.3; // å¼µåŠ›ï¼ˆ0-1ã€ä½ã„ã»ã©ãªã‚ã‚‰ã‹ï¼‰
                            const cp1x = p1.x + (p2.x - p0.x) * tension;
                            const cp1y = p1.y + (p2.y - p0.y) * tension;
                            const cp2x = p2.x - (p3.x - p1.x) * tension;
                            const cp2y = p2.y - (p3.y - p1.y) * tension;

                            ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, p2.x, p2.y);
                            ctx.stroke();
                        }

                        // â˜… è¿½åŠ ï¼šè»Œè·¡ã®çµ‚ç«¯ã«å…‰ã‚‹åŠ¹æœ
                        if (this.trail.length > 0) {
                            const lastPoint = this.trail[this.trail.length - 1];
                            const glowRadius = 3;

                            const glowGradient = ctx.createRadialGradient(
                                lastPoint.x, lastPoint.y, 0,
                                lastPoint.x, lastPoint.y, glowRadius
                            );
                            glowGradient.addColorStop(0, this.color + 'AA');
                            glowGradient.addColorStop(0.5, this.color + '66');
                            glowGradient.addColorStop(1, this.color + '00');

                            ctx.fillStyle = glowGradient;
                            ctx.beginPath();
                            ctx.arc(lastPoint.x, lastPoint.y, glowRadius, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }

                    // â˜… å¤‰æ›´ï¼šã‚¿ã‚¤ãƒ—åˆ¥æç”»
                    switch (this.type) {
                        case 'blackHole':
                            this.drawBlackHole();
                            break;
                        case 'neutronStar':
                            this.drawNeutronStar();
                            break;
                        case 'whiteDwarf':
                            this.drawWhiteDwarf();
                            break;
                        case 'pulsar':
                            this.drawPulsar();
                            break;
                        case 'planetSystem':
                            this.drawPlanetSystem();
                            break;
                        default:
                            this.drawNormalBody();
                            break;
                    }

                } catch (error) {
                    console.warn('Body draw error:', error);
                }
            }

            // â˜… è¿½åŠ ï¼šä¸­æ€§å­æ˜Ÿã®æç”»
            drawNeutronStar() {
                const radius = Math.sqrt(this.mass) * 0.8; // é€šå¸¸ã‚ˆã‚Šå°ã•ã„

                // å¼·ã„ç£å ´ã®å¯è¦–åŒ–
                for (let field = 0; field < 4; field++) {
                    const fieldAngle = this.rotation + (field * Math.PI / 2);
                    const fieldRadius = radius * (2 + field * 0.5);

                    ctx.strokeStyle = `rgba(147, 112, 219, ${0.3 - field * 0.05})`;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, fieldRadius, fieldAngle - 0.3, fieldAngle + 0.3);
                    ctx.stroke();
                }

                // æœ¬ä½“
                const coreGradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, radius);
                coreGradient.addColorStop(0, '#FFFFFF');
                coreGradient.addColorStop(0.3, '#E6E6FA');
                coreGradient.addColorStop(0.7, '#9370DB');
                coreGradient.addColorStop(1, '#4B0082');

                ctx.fillStyle = coreGradient;
                ctx.beginPath();
                ctx.arc(this.x, this.y, radius, 0, Math.PI * 2);
                ctx.fill();
            }

            // â˜… è¿½åŠ ï¼šç™½è‰²çŸ®æ˜Ÿã®æç”»
            drawWhiteDwarf() {
                const radius = Math.sqrt(this.mass) * 1.2;

                // æ¸©åº¦ã«ã‚ˆã‚‹è‰²å¤‰åŒ–
                const tempFactor = this.temperature;
                const r = Math.floor(255 * tempFactor);
                const g = Math.floor(255 * tempFactor * 0.9);
                const b = Math.floor(255 * (0.8 + tempFactor * 0.2));

                // å†·å´ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
                const coolGradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, radius * 2);
                coolGradient.addColorStop(0, `rgb(${r}, ${g}, ${b})`);
                coolGradient.addColorStop(0.5, `rgba(${r}, ${g}, ${b}, 0.7)`);
                coolGradient.addColorStop(1, `rgba(${r}, ${g}, ${b}, 0.1)`);

                ctx.fillStyle = coolGradient;
                ctx.beginPath();
                ctx.arc(this.x, this.y, radius * 2, 0, Math.PI * 2);
                ctx.fill();

                // æœ¬ä½“
                const coreGradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, radius);
                coreGradient.addColorStop(0, '#FFFFFF');
                coreGradient.addColorStop(0.6, this.color);
                coreGradient.addColorStop(1, `rgba(${r}, ${g}, ${b}, 0.8)`);

                ctx.fillStyle = coreGradient;
                ctx.beginPath();
                ctx.arc(this.x, this.y, radius, 0, Math.PI * 2);
                ctx.fill();
            }

            // â˜… ä¿®æ­£ï¼šãƒ‘ãƒ«ã‚µãƒ¼ã®æç”»ï¼ˆã‚ˆã‚Šæ˜ç¢ºãªè¦–è¦šåŠ¹æœï¼‰
            drawPulsar() {
                const radius = Math.sqrt(this.mass) * 0.7; // â˜… ä¿®æ­£ï¼šä¸­æ€§å­æ˜Ÿã¯ã‚ˆã‚Šå°ã•ã

                // â˜… ä¿®æ­£ï¼šç£å ´å¼·åº¦ã«åŸºã¥ããƒ“ãƒ¼ãƒ æç”»
                const beamIntensity = Math.min(this.magneticField / 1.5, 1.0);

                for (let beam = 0; beam < 2; beam++) {
                    const beamAngle = this.beamRotation + beam * Math.PI;
                    // â˜… ä¿®æ­£ï¼šãƒ“ãƒ¼ãƒ é•·ã¯ç£å ´å¼·åº¦ã¨å›è»¢å‘¨æœŸã«ä¾å­˜
                    const beamLength = radius * (8 + this.magneticField * 4) * (0.1 / this.rotationPeriod);

                    const beamWidth = 2 + Math.sin(this.beamRotation * 12) * 1 * beamIntensity;

                    const beamGradient = ctx.createLinearGradient(
                        this.x, this.y,
                        this.x + Math.cos(beamAngle) * beamLength,
                        this.y + Math.sin(beamAngle) * beamLength
                    );

                    // â˜… ä¿®æ­£ï¼šç£å ´å¼·åº¦ã«ã‚ˆã‚‹ãƒ“ãƒ¼ãƒ è‰²ã®å¤‰åŒ–
                    const alpha = 0.7 * beamIntensity;
                    beamGradient.addColorStop(0, `rgba(0, 255, 255, ${alpha})`);
                    beamGradient.addColorStop(0.3, `rgba(0, 255, 255, ${alpha * 0.7})`);
                    beamGradient.addColorStop(0.7, `rgba(0, 255, 255, ${alpha * 0.4})`);
                    beamGradient.addColorStop(1, 'rgba(0, 255, 255, 0)');

                    ctx.strokeStyle = beamGradient;
                    ctx.lineWidth = beamWidth;
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y);
                    ctx.lineTo(
                        this.x + Math.cos(beamAngle) * beamLength,
                        this.y + Math.sin(beamAngle) * beamLength
                    );
                    ctx.stroke();
                }

                // æœ¬ä½“ï¼ˆä¸­æ€§å­æ˜Ÿãƒ™ãƒ¼ã‚¹ï¼‰
                this.drawNeutronStar();

                // â˜… ä¿®æ­£ï¼šãƒ‘ãƒ«ã‚µãƒ¼ç‰¹æœ‰ã®ã‚¨ãƒ•ã‚§ã‚¯ãƒˆï¼ˆç‰©ç†çš„ã«æ­£ç¢ºï¼‰
                const pulseFrequency = 1.0 / this.rotationPeriod; // ãƒ‘ãƒ«ã‚¹å‘¨æ³¢æ•°
                const pulseIntensity = 0.5 + 0.5 * Math.sin(this.beamRotation * pulseFrequency) * beamIntensity;
                const pulseRadius = radius * (1.5 + pulseIntensity * 0.8);

                ctx.strokeStyle = `rgba(0, 255, 255, ${0.3 + pulseIntensity * 0.5})`;
                ctx.lineWidth = 1 + pulseIntensity;
                ctx.beginPath();
                ctx.arc(this.x, this.y, pulseRadius, 0, Math.PI * 2);
                ctx.stroke();

                // â˜… è¿½åŠ ï¼šç£æ°—åœã®å¯è¦–åŒ–
                if (this.magneticField > 0.8) {
                    ctx.strokeStyle = `rgba(0, 255, 255, 0.2)`;
                    ctx.lineWidth = 1;
                    ctx.setLineDash([3, 3]);
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, radius * this.magneticField * 4, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
            }

            // â˜… è¿½åŠ ï¼šæƒ‘æ˜Ÿç³»ã®æç”»
            drawPlanetSystem() {
                // æ’æ˜Ÿæœ¬ä½“
                this.drawNormalBody();

                // æƒ‘æ˜Ÿã®æç”»
                this.planets.forEach(planet => {
                    const px = this.x + Math.cos(planet.angle) * planet.distance;
                    const py = this.y + Math.sin(planet.angle) * planet.distance;

                    // è»Œé“ç·š
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, planet.distance, 0, Math.PI * 2);
                    ctx.stroke();

                    // æƒ‘æ˜Ÿ
                    const planetGradient = ctx.createRadialGradient(px, py, 0, px, py, planet.size);
                    planetGradient.addColorStop(0, '#FFFFFF');
                    planetGradient.addColorStop(0.7, planet.color);
                    planetGradient.addColorStop(1, planet.color + '88');

                    ctx.fillStyle = planetGradient;
                    ctx.beginPath();
                    ctx.arc(px, py, planet.size, 0, Math.PI * 2);
                    ctx.fill();
                });
            }

            // â˜… è¿½åŠ ï¼šãƒ–ãƒ©ãƒƒã‚¯ãƒ›ãƒ¼ãƒ«æç”»
            drawBlackHole() {
                const radius = this.eventHorizonRadius;

                // é™ç€å††ç›¤ã®æç”»
                for (let ring = 4; ring >= 1; ring--) {
                    const ringRadius = radius * (2 + ring * 0.5);
                    const ringGradient = ctx.createRadialGradient(this.x, this.y, radius, this.x, this.y, ringRadius);

                    const intensity = 0.3 / ring;
                    const rotation = this.blackHoleRotation * ring * 0.5;

                    ringGradient.addColorStop(0, 'transparent');
                    ringGradient.addColorStop(0.3, `rgba(255, 107, 0, ${intensity})`);
                    ringGradient.addColorStop(0.7, `rgba(255, 69, 0, ${intensity * 0.7})`);
                    ringGradient.addColorStop(1, 'transparent');

                    ctx.fillStyle = ringGradient;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, ringRadius, 0, Math.PI * 2);
                    ctx.fill();
                }

                // é‡åŠ›ãƒ¬ãƒ³ã‚ºåŠ¹æœï¼ˆæ­ªã¿è¡¨ç¾ï¼‰
                const lensRadius = radius * 4;
                const lensGradient = ctx.createRadialGradient(this.x, this.y, radius, this.x, this.y, lensRadius);
                lensGradient.addColorStop(0, 'transparent');
                lensGradient.addColorStop(0.6, 'rgba(255, 255, 255, 0.05)');
                lensGradient.addColorStop(0.8, 'rgba(255, 255, 255, 0.1)');
                lensGradient.addColorStop(1, 'transparent');

                ctx.fillStyle = lensGradient;
                ctx.beginPath();
                ctx.arc(this.x, this.y, lensRadius, 0, Math.PI * 2);
                ctx.fill();

                // äº‹è±¡ã®åœ°å¹³ç·šï¼ˆå®Œå…¨ãªé»’ï¼‰
                ctx.fillStyle = '#000000';
                ctx.beginPath();
                ctx.arc(this.x, this.y, radius, 0, Math.PI * 2);
                ctx.fill();

                // äº‹è±¡ã®åœ°å¹³ç·šã®å¢ƒç•Œ
                ctx.strokeStyle = 'rgba(2, 2, 2, 0.3)';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.arc(this.x, this.y, radius, 0, Math.PI * 2);
                ctx.stroke();
                ctx.setLineDash([]);
            }

            // â˜… è¿½åŠ ï¼šé€šå¸¸å¤©ä½“æç”»ï¼ˆæ—¢å­˜ã®drawå†…å®¹ã‚’ç§»å‹•ï¼‰
            drawNormalBody() {
                // å¤©ä½“æç”»
                const baseRadius = Math.sqrt(this.mass) * 1.5;
                const pulseMultiplier = 1 + Math.sin(this.pulsePhase) * 0.1;
                const radius = baseRadius * pulseMultiplier;

                // å¤–å´ã®ã‚ªãƒ¼ãƒ©ï¼ˆè¤‡æ•°å±¤ï¼‰
                for (let layer = 3; layer >= 1; layer--) {
                    const auraRadius = radius * (2 + layer * 0.8);
                    const auraGradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, auraRadius);
                    const intensity = 0.1 / layer;
                    auraGradient.addColorStop(0, this.color + Math.floor(intensity * 255).toString(16).padStart(2, '0'));
                    auraGradient.addColorStop(0.5, this.color + Math.floor(intensity * 128).toString(16).padStart(2, '0'));
                    auraGradient.addColorStop(1, 'transparent');

                    ctx.fillStyle = auraGradient;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, auraRadius, 0, Math.PI * 2);
                    ctx.fill();
                }

                // ãƒ¡ã‚¤ãƒ³ã®å…‰è¼ª
                const glowGradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, radius * 2);
                glowGradient.addColorStop(0, this.color + 'AA');
                glowGradient.addColorStop(0.6, this.color + '44');
                glowGradient.addColorStop(1, 'transparent');
                ctx.fillStyle = glowGradient;
                ctx.beginPath();
                ctx.arc(this.x, this.y, radius * 2, 0, Math.PI * 2);
                ctx.fill();

                // ã‚³ã‚¢éƒ¨åˆ†ï¼ˆè¤‡æ•°å±¤ã®ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ï¼‰
                const coreGradient = ctx.createRadialGradient(
                    this.x - radius * 0.3, this.y - radius * 0.3, 0,
                    this.x, this.y, radius
                );
                coreGradient.addColorStop(0, '#ffffff');
                coreGradient.addColorStop(0.2, '#ffffff');
                coreGradient.addColorStop(0.4, this.color);
                coreGradient.addColorStop(0.7, this.color + 'CC');
                coreGradient.addColorStop(1, this.color + '88');

                ctx.fillStyle = coreGradient;
                ctx.beginPath();
                ctx.arc(this.x, this.y, radius, 0, Math.PI * 2);
                ctx.fill();

                // å†…å´ã®ã‚¨ãƒãƒ«ã‚®ãƒ¼ã‚³ã‚¢
                const energyGradient = ctx.createRadialGradient(
                    this.x - radius * 0.2, this.y - radius * 0.2, 0,
                    this.x, this.y, radius * 0.6
                );
                energyGradient.addColorStop(0, '#ffffff');
                energyGradient.addColorStop(0.5, this.color + 'DD');
                energyGradient.addColorStop(1, 'transparent');

                ctx.fillStyle = energyGradient;
                ctx.beginPath();
                ctx.arc(this.x, this.y, radius * 0.6, 0, Math.PI * 2);
                ctx.fill();

                // ã‚¹ãƒšã‚­ãƒ¥ãƒ©ãƒã‚¤ãƒ©ã‚¤ãƒˆ
                ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                ctx.beginPath();
                ctx.arc(this.x - radius * 0.4, this.y - radius * 0.4, radius * 0.25, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        /**
         * å¤©ä½“è¡çªã®æ¤œå‡ºã¨å‡¦ç†
         */
        function handleCollisions() {
            for (let i = 0; i < bodies.length; i++) {
                for (let j = i + 1; j < bodies.length; j++) {
                    if (!bodies[i].isValid || !bodies[j].isValid) continue;

                    const dx = bodies[j].x - bodies[i].x;
                    const dy = bodies[j].y - bodies[i].y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    // â˜… ä¿®æ­£ï¼šè¡çªåˆ¤å®šã«ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã®å€¤ã‚’åæ˜ 
                    const radius1 = Math.sqrt(bodies[i].mass) * 1.5;
                    const radius2 = Math.sqrt(bodies[j].mass) * 1.5;
                    const collisionDistance = (radius1 + radius2) * collisionSensitivity; // â˜… å¤‰æ›´ï¼šæ„Ÿåº¦ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’ä½¿ç”¨

                    if (distance < collisionDistance) {
                        // è³ªé‡ã®å¤§ãã„æ–¹ã‚’æ®‹ã™ï¼ˆè³ªé‡ãŒåŒã˜å ´åˆã¯iç•ªç›®ã‚’æ®‹ã™ï¼‰
                        let survivor, victim;
                        if (bodies[i].mass >= bodies[j].mass) {
                            survivor = bodies[i];
                            victim = bodies[j];
                        } else {
                            survivor = bodies[j];
                            victim = bodies[i];
                        }

                        // é‹å‹•é‡ä¿å­˜ã®æ³•å‰‡ã§æ–°ã—ã„é€Ÿåº¦ã‚’è¨ˆç®—
                        const totalMass = survivor.mass + victim.mass;
                        const newVx = (survivor.mass * survivor.vx + victim.mass * victim.vx) / totalMass;
                        const newVy = (survivor.mass * survivor.vy + victim.mass * victim.vy) / totalMass;

                        // â˜… è¿½åŠ ï¼šè¡çªã«ã‚ˆã‚‹è§’é‹å‹•é‡ã®è¨ˆç®—
                        const relativeVx = victim.vx - survivor.vx;
                        const relativeVy = victim.vy - survivor.vy;
                        const impactSpeed = Math.sqrt(relativeVx * relativeVx + relativeVy * relativeVy);

                        // è³ªé‡ã®é‡å¿ƒã§æ–°ã—ã„ä½ç½®ã‚’è¨ˆç®—
                        const newX = (survivor.mass * survivor.x + victim.mass * victim.x) / totalMass;
                        const newY = (survivor.mass * survivor.y + victim.mass * victim.y) / totalMass;

                        // ç”Ÿå­˜è€…ã®å±æ€§ã‚’æ›´æ–°
                        survivor.x = newX;
                        survivor.y = newY;
                        survivor.vx = newVx;
                        survivor.vy = newVy;
                        survivor.mass = Math.min(totalMass, 400); // æœ€å¤§è³ªé‡åˆ¶é™
                        survivor.trail = []; // è»Œè·¡ã‚’ãƒªã‚»ãƒƒãƒˆ

                        // è¡çªã‚¨ãƒ•ã‚§ã‚¯ãƒˆç”Ÿæˆ
                        createCollisionEffect(newX, newY, survivor.color, victim.color);

                        // è¢«å®³è€…ã‚’ç„¡åŠ¹åŒ–
                        victim.isValid = false;

                        // â˜… è¿½åŠ ï¼šè¡çªæ™‚åˆ»ã®è¨˜éŒ²ï¼ˆãƒ‘ãƒ«ã‚µãƒ¼ç”Ÿæˆåˆ¤å®šç”¨ï¼‰
                        survivor.lastCollisionTime = time;
                        survivor.collisionImpactSpeed = impactSpeed;

                        // â˜… è¿½åŠ ï¼šé«˜ã‚¨ãƒãƒ«ã‚®ãƒ¼è¡çªã§ãƒ‘ãƒ«ã‚µãƒ¼åŒ–ã®å¯èƒ½æ€§
                        if (impactSpeed > 80 && totalMass >= PULSAR_MASS_THRESHOLD && totalMass < NEUTRON_STAR_MASS_THRESHOLD) {
                            // 30%ã®ç¢ºç‡ã§è¡çªã«ã‚ˆã‚Šãƒ‘ãƒ«ã‚µãƒ¼åŒ–
                            if (Math.random() < 0.3) {
                                survivor.type = 'pulsar';
                                survivor.initializeByType();
                                console.log(`é«˜ã‚¨ãƒãƒ«ã‚®ãƒ¼è¡çªã«ã‚ˆã‚Šãƒ‘ãƒ«ã‚µãƒ¼ç”Ÿæˆï¼è³ªé‡: ${survivor.mass.toFixed(1)}, è¡çªé€Ÿåº¦: ${impactSpeed.toFixed(1)}`);
                            }
                        }

                        console.log(`å¤©ä½“è¡çª: è³ªé‡ ${survivor.mass.toFixed(1)}, è¡çªé€Ÿåº¦ ${impactSpeed.toFixed(1)}`);
                        return; // 1ãƒ•ãƒ¬ãƒ¼ãƒ ã«1å›ã®è¡çªã®ã¿å‡¦ç†
                    }
                }
            }
        }

        /**
         * è¡çªã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®ç”Ÿæˆ
         */
        function createCollisionEffect(x, y, color1, color2) {
            // å¤šæ•°ã®ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚’ç”Ÿæˆ
            for (let i = 0; i < 20; i++) {
                const angle = (Math.PI * 2 * i) / 20;
                const speed = 3 + Math.random() * 4;
                const px = x + Math.cos(angle) * 10;
                const py = y + Math.sin(angle) * 10;

                // ä¸¡æ–¹ã®è‰²ã‹ã‚‰ãƒ©ãƒ³ãƒ€ãƒ ã«é¸æŠ
                const effectColor = Math.random() < 0.5 ? color1 : color2;

                const particle = new Particle(px, py, effectColor);
                particle.vx = Math.cos(angle) * speed;
                particle.vy = Math.sin(angle) * speed;
                particle.life = 1.5; // é€šå¸¸ã‚ˆã‚Šé•·æŒã¡
                particle.size = 2 + Math.random() * 3;
                particles.push(particle);
            }

            // ä¸­å¿ƒéƒ¨ã®æ˜ã‚‹ã„ãƒ•ãƒ©ãƒƒã‚·ãƒ¥
            for (let i = 0; i < 5; i++) {
                const particle = new Particle(x, y, '#ffffff');
                particle.vx = (Math.random() - 0.5) * 2;
                particle.vy = (Math.random() - 0.5) * 2;
                particle.life = 1.0;
                particle.size = 4 + Math.random() * 2;
                particles.push(particle);
            }
        }

        /**
         * â˜… ä¿®æ­£ï¼šé‡åŠ›è¨ˆç®—ã®æœ€é©åŒ–
         */
        function calculateGravity(dt) {
            try {
                const G = gravity * 50;
                bodies = bodies.filter(b => b.isValid);
                if (bodies.length < 2) return;

                // å„å¤©ä½“ã«å¯¾ã™ã‚‹åŠ›ã‚’è¨ˆç®—
                for (let i = 0; i < bodies.length; i++) {
                    let fx = 0, fy = 0;

                    for (let j = 0; j < bodies.length; j++) {
                        if (i === j) continue;

                        const dx = bodies[j].x - bodies[i].x;
                        const dy = bodies[j].y - bodies[i].y;
                        const distSq = dx * dx + dy * dy;

                        // ã‚½ãƒ•ãƒˆãƒ‹ãƒ³ã‚°ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
                        const softening = 100;
                        const dist = Math.sqrt(distSq + softening);

                        // â˜… ä¿®æ­£ï¼šãƒ–ãƒ©ãƒƒã‚¯ãƒ›ãƒ¼ãƒ«ã®é‡åŠ›åŠ¹æœ
                        let effectiveG = G;
                        if (bodies[j].isBlackHole) {
                            effectiveG *= BLACK_HOLE_GRAVITY_MULTIPLIER;
                        }

                        // é‡åŠ›ã®å¤§ãã•
                        const F = effectiveG * bodies[i].mass * bodies[j].mass / (dist * dist);

                        // åŠ›ã‚’åˆ†è§£
                        fx += F * dx / dist;
                        fy += F * dy / dist;
                    }

                    // é€Ÿåº¦æ›´æ–°
                    bodies[i].vx += (fx / bodies[i].mass) * dt;
                    bodies[i].vy += (fy / bodies[i].mass) * dt;

                    // â˜… ä¿®æ­£ï¼šé€Ÿåº¦åˆ¶é™ã‚’é©åˆ‡ã«
                    const maxSpeed = 300; // â˜… ä¿®æ­£ï¼šå°‘ã—ä¸‹ã’ã‚‹
                    const speed = Math.sqrt(bodies[i].vx * bodies[i].vx + bodies[i].vy * bodies[i].vy);
                    if (speed > maxSpeed) {
                        const factor = maxSpeed / speed;
                        bodies[i].vx *= factor;
                        bodies[i].vy *= factor;
                    }
                }

                // è¡çªåˆ¤å®š
                if (enableCollisions) {
                    handleCollisions();
                }

            } catch (err) {
                console.error('Gravity calculation error:', err);
            }
        }

        // â˜… ä¿®æ­£ï¼šã‚¨ãƒãƒ«ã‚®ãƒ¼è¨ˆç®—ã®ä¿‚æ•°ã‚’çµ±ä¸€
        function calculateEnergy() {
            try {
                const G = gravity * 50; // â˜… ä¿®æ­£ï¼šcalculateGravityã¨åŒã˜ä¿‚æ•°
                let kinetic = 0, potential = 0;

                // é‹å‹•ã‚¨ãƒãƒ«ã‚®ãƒ¼
                bodies.forEach(b => {
                    if (!b.isValid) return;
                    kinetic += 0.5 * b.mass * (b.vx * b.vx + b.vy * b.vy);
                });

                // ãƒãƒ†ãƒ³ã‚·ãƒ£ãƒ«ã‚¨ãƒãƒ«ã‚®ãƒ¼
                for (let i = 0; i < bodies.length; i++) {
                    for (let j = i + 1; j < bodies.length; j++) {
                        if (!bodies[i].isValid || !bodies[j].isValid) continue;
                        const dx = bodies[j].x - bodies[i].x;
                        const dy = bodies[j].y - bodies[i].y;
                        const d = Math.sqrt(dx * dx + dy * dy) + 10;
                        potential -= G * bodies[i].mass * bodies[j].mass / d;
                    }
                }

                return (kinetic + potential) / 10000; // â˜… ä¿®æ­£ï¼šã‚¹ã‚±ãƒ¼ãƒ«èª¿æ•´
            } catch {
                return 0;
            }
        }

        /**
         * FPSè¨ˆç®—
         */
        function updateFPS() {
            frameCount++;
            const now = Date.now();

            if (now - lastFpsUpdate >= 1000) {
                currentFps = Math.round((frameCount * 1000) / (now - lastFpsUpdate));
                frameCount = 0;
                lastFpsUpdate = now;

                document.getElementById('fpsDisplay').textContent = currentFps;
            }
        }

        /**
         * ãƒ¡ã‚¤ãƒ³ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ«ãƒ¼ãƒ—
         */
        function animate() {
            if (!isRunning) return;

            try {
                // èƒŒæ™¯æç”»
                drawBackground();

                // é‡åŠ›å ´æç”»ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰
                if (showGravityField) {
                    calculateAndDrawGravityField();
                    ctx.globalAlpha = 1.0;
                    ctx.drawImage(gravityFieldCanvas, 0, 0);
                }

                // ç‰©ç†è¨ˆç®—
                const dt = timeStep * speed;
                calculateGravity(dt);

                // å¤©ä½“æ›´æ–°ãƒ»æç”»
                bodies.forEach(body => {
                    body.update(dt);
                    body.draw();
                });

                // â˜… ä¿®æ­£ï¼šãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ç®¡ç†ã®æœ€é©åŒ–
                for (let i = particles.length - 1; i >= 0; i--) {
                    particles[i].update();
                    particles[i].draw();
                    if (particles[i].isDead()) {
                        particles.splice(i, 1);
                    }
                }

                // â˜… è¿½åŠ ï¼šãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«æ•°åˆ¶é™
                if (particles.length > 500) {
                    particles.splice(0, particles.length - 400);
                }

                // æ™‚é–“æ›´æ–°
                time += dt;

                // UIæ›´æ–°
                updateDisplay();
                updateFPS();

                animationId = requestAnimationFrame(animate);

            } catch (error) {
                console.error('Animation error:', error);
                showError('ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚');
                stopSimulation();
            }
        }

        /**
         * è¡¨ç¤ºæ›´æ–°
         */
        function updateDisplay() {
            try {
                const validBodies = bodies.filter(b => b.isValid);
                const typeCounts = {};

                validBodies.forEach(body => {
                    const typeName = body.getTypeNameJapanese();
                    typeCounts[typeName] = (typeCounts[typeName] || 0) + 1;
                });

                document.getElementById('bodyCount').textContent = validBodies.length;
                document.getElementById('timeDisplay').textContent = Math.floor(time);

                const energy = calculateEnergy();
                document.getElementById('energyDisplay').textContent = energy.toFixed(0);

                // â˜… å¤‰æ›´ï¼šå¤©ä½“ã‚¿ã‚¤ãƒ—åˆ¥æƒ…å ±ã‚’è¡¨ç¤º
                let typeInfo = '';
                Object.entries(typeCounts).forEach(([type, count]) => {
                    if (typeInfo) typeInfo += ', ';
                    typeInfo += `${type}:${count}`;
                });

                if (typeInfo) {
                    document.getElementById('bodyCount').textContent += ` (${typeInfo})`;
                }

            } catch (error) {
                console.warn('Display update error:', error);
            }
        }

        /**
         * ã‚¨ãƒ©ãƒ¼è¡¨ç¤º
         */
        function showError(message) {
            const errorElement = document.getElementById('errorMessage');
            errorElement.textContent = message;
            errorElement.style.display = 'block';

            setTimeout(() => {
                errorElement.style.display = 'none';
            }, 3000);
        }

        /**
         * ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³åœæ­¢
         */
        function stopSimulation() {
            isRunning = false;
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }

            const btn = document.getElementById('playPause');
            btn.textContent = 'é–‹å§‹';
            btn.classList.remove('active');
        }

        // ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«
        document.getElementById('playPause').addEventListener('click', () => {
            isRunning = !isRunning;
            const btn = document.getElementById('playPause');
            btn.textContent = isRunning ? 'åœæ­¢' : 'é–‹å§‹';
            btn.classList.toggle('active', isRunning);
            if (isRunning) {
                animate();
            }
        });

        document.getElementById('reset').addEventListener('click', () => {
            if (currentPresetType) {
                setPreset(currentPresetType);
            } else {
                bodies.forEach(body => {
                    body.vx = 0;
                    body.vy = 0;
                    body.trail = [];
                    body.isValid = true;
                });
                particles = [];
                time = 0;
                errorCount = 0;
                updateDisplay();
            }
        });

        document.getElementById('clear').addEventListener('click', () => {
            currentPresetType = null;
            bodies = [];
            particles = [];
            time = 0;
            errorCount = 0;
            updateDisplay();
            drawBackground();
        });

        // ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼
        document.getElementById('speedSlider').addEventListener('input', (e) => {
            speed = parseFloat(e.target.value);
            document.getElementById('speedValue').textContent = speed.toFixed(1);
        });

        document.getElementById('gravitySlider').addEventListener('input', (e) => {
            gravity = parseInt(e.target.value);
            document.getElementById('gravityValue').textContent = gravity;
        });

        document.getElementById('trailSlider').addEventListener('input', (e) => {
            trailLength = parseInt(e.target.value);
            document.getElementById('trailValue').textContent = trailLength;
        });

        document.getElementById('trailToggle').addEventListener('click', () => {
            showTrails = !showTrails;
            const btn = document.getElementById('trailToggle');
            btn.classList.toggle('active', showTrails);
            btn.textContent = showTrails ? 'è»Œè·¡è¡¨ç¤º' : 'è»Œè·¡éè¡¨ç¤º';

            if (!showTrails) {
                bodies.forEach(body => body.trail = []);
            }
        });

        // â˜… è¿½åŠ ï¼šè¡çªåˆ¤å®šåˆ‡ã‚Šæ›¿ãˆã‚¤ãƒ™ãƒ³ãƒˆ
        document.getElementById('collisionToggle').addEventListener('click', () => {
            enableCollisions = !enableCollisions;
            const btn = document.getElementById('collisionToggle');
            btn.classList.toggle('active', enableCollisions);
            btn.textContent = enableCollisions ? 'è¡çªæœ‰åŠ¹' : 'è¡çªç„¡åŠ¹';
        });

        // â˜… è¿½åŠ ï¼šé‡åŠ›å ´è¡¨ç¤ºåˆ‡ã‚Šæ›¿ãˆã‚¤ãƒ™ãƒ³ãƒˆ
        document.getElementById('gravityFieldToggle').addEventListener('click', () => {
            showGravityField = !showGravityField;
            const btn = document.getElementById('gravityFieldToggle');
            btn.classList.toggle('active', showGravityField);
            btn.textContent = showGravityField ? 'é‡åŠ›å ´è¡¨ç¤º' : 'é‡åŠ›å ´éè¡¨ç¤º';

            if (!showGravityField && gravityFieldCtx) {
                // é‡åŠ›å ´ã‚’éè¡¨ç¤ºã«ã™ã‚‹æ™‚ã¯ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚’ã‚¯ãƒªã‚¢
                gravityFieldCtx.clearRect(0, 0, canvas.width, canvas.height);
            }
        });

        // â˜… è¿½åŠ ï¼šè¡çªåˆ¤å®šæ„Ÿåº¦ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
        document.getElementById('collisionSensitivitySlider').addEventListener('input', (e) => {
            collisionSensitivity = parseFloat(e.target.value);
            document.getElementById('collisionSensitivityValue').textContent = collisionSensitivity.toFixed(1);
        });

        // ãƒ—ãƒªã‚»ãƒƒãƒˆï¼ˆåˆæœŸé€Ÿåº¦ã‚’èª¿æ•´ï¼‰
        function setPreset(type) {
            try {
                currentPresetType = type;
                bodies = [];
                particles = []; // â˜… è¿½åŠ ï¼šãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚‚ã‚¯ãƒªã‚¢
                time = 0;
                errorCount = 0;

                const cx = canvas.width / 2;
                const cy = canvas.height / 2;

                switch (type) {
                    case 'binary':
                        bodies.push(new Body(cx - 40, cy, 30, 30, 35)); // â˜… ä¿®æ­£ï¼šãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿èª¿æ•´
                        bodies.push(new Body(cx + 40, cy, -30, -30, 35));
                        break;

                    case 'triangle':
                        const r = 120; // â˜… ä¿®æ­£ï¼šè·é›¢ã‚’å¤§ãã
                        for (let i = 0; i < 3; i++) {
                            const angle = (i * 2 * Math.PI) / 3 - Math.PI / 2;
                            const x = cx + r * Math.cos(angle);
                            const y = cy + r * Math.sin(angle);
                            const vx = -35 * Math.sin(angle); // â˜… ä¿®æ­£ï¼šé€Ÿåº¦èª¿æ•´
                            const vy = 35 * Math.cos(angle);
                            bodies.push(new Body(x, y, vx, vy, 30));
                        }
                        break;

                    case 'figure_eight':
                        // â˜… ä¿®æ­£ï¼š8ã®å­—è»Œé“ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿èª¿æ•´
                        bodies.push(new Body(cx, cy, 25, 38, 28));
                        bodies.push(new Body(cx - 180, cy, -12.5, -19, 28));
                        bodies.push(new Body(cx + 180, cy, -12.5, -19, 28));
                        break;

                    case 'random':
                        const count = 3 + Math.floor(Math.random() * 3); // â˜… ä¿®æ­£ï¼šæœ€å¤§æ•°ã‚’æ¸›ã‚‰ã™
                        for (let i = 0; i < count; i++) {
                            const x = 120 + Math.random() * (canvas.width - 240); // â˜… ä¿®æ­£ï¼šãƒãƒ¼ã‚¸ãƒ³æ‹¡å¤§
                            const y = 120 + Math.random() * (canvas.height - 240);
                            const vx = (Math.random() - 0.5) * 60; // â˜… ä¿®æ­£ï¼šé€Ÿåº¦ç¯„å›²èª¿æ•´
                            const vy = (Math.random() - 0.5) * 60;
                            const mass = 20 + Math.random() * 25; // â˜… ä¿®æ­£ï¼šè³ªé‡ç¯„å›²èª¿æ•´
                            bodies.push(new Body(x, y, vx, vy, mass));
                        }
                        break;
                }

                updateDisplay();
                drawBackground();

                // è‡ªå‹•é–‹å§‹
                if (!isRunning) {
                    isRunning = true;
                    const btn = document.getElementById('playPause');
                    btn.textContent = 'åœæ­¢';
                    btn.classList.add('active');
                    animate();
                }

            } catch (error) {
                console.error('Preset error:', error);
                showError('ãƒ—ãƒªã‚»ãƒƒãƒˆè¨­å®šã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚');
            }
        }

        /**
         * èƒŒæ™¯æç”»ï¼ˆæ˜Ÿã®ãã‚‰ã‚ãåŠ¹æœè¿½åŠ ï¼‰
         */
        function drawBackground() {
            if (!backgroundGenerated) {
                generateStars();
            }

            // ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³èƒŒæ™¯
            const gradient = ctx.createRadialGradient(
                canvas.width / 2, canvas.height / 2, 0,
                canvas.width / 2, canvas.height / 2, Math.max(canvas.width, canvas.height)
            );
            gradient.addColorStop(0, 'rgba(20, 20, 45, 0.95)');
            gradient.addColorStop(0.5, 'rgba(15, 15, 35, 0.97)');
            gradient.addColorStop(1, 'rgba(10, 10, 25, 0.98)');

            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // æ˜Ÿç©ºåŠ¹æœï¼ˆãã‚‰ã‚ãè¿½åŠ ï¼‰
            for (let star of stars) {
                star.twinkle += 0.02;
                const twinkleIntensity = (Math.sin(star.twinkle) + 1) * 0.5;
                const opacity = star.opacity * twinkleIntensity;

                ctx.fillStyle = `rgba(255, 255, 255, ${opacity})`;
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                ctx.fill();

                // æ˜ã‚‹ã„æ˜Ÿã«ã¯ã‚°ãƒ­ãƒ¼åŠ¹æœ
                if (star.size > 1.5) {
                    ctx.fillStyle = `rgba(255, 255, 255, ${opacity * 0.3})`;
                    ctx.beginPath();
                    ctx.arc(star.x, star.y, star.size * 3, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }

        // ã‚¿ãƒƒãƒãƒ»ãƒã‚¦ã‚¹ã‚¤ãƒ™ãƒ³ãƒˆ
        function getEventPos(e) {
            const rect = canvas.getBoundingClientRect();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            return {
                x: clientX - rect.left,
                y: clientY - rect.top
            };
        }

        function findBodyAt(x, y) {
            for (let body of bodies) {
                if (!body.isValid) continue;
                const dx = x - body.x;
                const dy = y - body.y;
                const radius = Math.sqrt(body.mass) * 1.5;
                if (dx * dx + dy * dy <= radius * radius) {
                    return body;
                }
            }
            return null;
        }

        // â˜… è¿½åŠ ï¼šãƒ„ãƒ¼ãƒ«ãƒãƒƒãƒ—é–¢é€£å¤‰æ•°
        let hoveredBody = null;
        let tooltip = null;
        let mousePos = { x: 0, y: 0 };

        /**
         * â˜… è¿½åŠ ï¼šãƒ„ãƒ¼ãƒ«ãƒãƒƒãƒ—ã®åˆæœŸåŒ–
         */
        function initializeTooltip() {
            tooltip = document.createElement('div');
            tooltip.className = 'tooltip';
            document.body.appendChild(tooltip);
        }

        /**
         * â˜… è¿½åŠ ï¼šå¤©ä½“ã®è©³ç´°æƒ…å ±ã‚’å–å¾—
         */
        function getBodyInfo(body) {
            const speed = Math.sqrt(body.vx * body.vx + body.vy * body.vy);
            const kineticEnergy = 0.5 * body.mass * speed * speed;

            // ä»–ã®å¤©ä½“ã¨ã®ç›¸äº’ä½œç”¨ã‚¨ãƒãƒ«ã‚®ãƒ¼ã‚’è¨ˆç®—
            let potentialEnergy = 0;
            const G = gravity * 50;

            bodies.forEach(otherBody => {
                if (otherBody !== body && otherBody.isValid) {
                    const dx = otherBody.x - body.x;
                    const dy = otherBody.y - body.y;
                    const distance = Math.sqrt(dx * dx + dy * dy) + 10;
                    potentialEnergy -= G * body.mass * otherBody.mass / distance;
                }
            });

            const totalEnergy = (kineticEnergy + potentialEnergy / 2) / 1000; // ã‚¹ã‚±ãƒ¼ãƒ«èª¿æ•´

            return {
                type: body.getTypeNameJapanese(),
                mass: body.mass.toFixed(1),
                speed: speed.toFixed(1),
                kineticEnergy: (kineticEnergy / 1000).toFixed(1),
                potentialEnergy: (potentialEnergy / 2000).toFixed(1), // é‡è¤‡ã‚«ã‚¦ãƒ³ãƒˆå›é¿
                totalEnergy: totalEnergy.toFixed(1),
                magneticField: body.magneticField ? body.magneticField.toFixed(2) : null,
                temperature: body.temperature ? body.temperature.toFixed(2) : null,
                rotationPeriod: body.rotationPeriod ? body.rotationPeriod.toFixed(3) : null,
                age: body.pulsarAge ? Math.floor(body.pulsarAge) : null,
                planets: body.planets ? body.planets.length : null
            };
        }

        /**
         * â˜… è¿½åŠ ï¼šãƒ„ãƒ¼ãƒ«ãƒãƒƒãƒ—ã®æ›´æ–°
         */
        function updateTooltip(body, x, y) {
            if (!tooltip || !body) return;

            const info = getBodyInfo(body);

            // ãƒ„ãƒ¼ãƒ«ãƒãƒƒãƒ—ã®ã‚¯ãƒ©ã‚¹ã‚’æ›´æ–°ï¼ˆå¤©ä½“ã‚¿ã‚¤ãƒ—ã«å¿œã˜ãŸè‰²åˆ†ã‘ï¼‰
            tooltip.className = `tooltip ${body.type}`;

            let content = `<div class="tooltip-title">${info.type}</div>`;

            // åŸºæœ¬æƒ…å ±
            content += `<div class="tooltip-row">
                <span class="tooltip-label">è³ªé‡:</span>
                <span class="tooltip-value">${info.mass}</span>
            </div>`;

            content += `<div class="tooltip-row">
                <span class="tooltip-label">é€Ÿåº¦:</span>
                <span class="tooltip-value">${info.speed}</span>
            </div>`;

            content += `<div class="tooltip-row">
                <span class="tooltip-label">é‹å‹•ã‚¨ãƒãƒ«ã‚®ãƒ¼:</span>
                <span class="tooltip-value">${info.kineticEnergy}</span>
            </div>`;

            content += `<div class="tooltip-row">
                <span class="tooltip-label">ä½ç½®ã‚¨ãƒãƒ«ã‚®ãƒ¼:</span>
                <span class="tooltip-value">${info.potentialEnergy}</span>
            </div>`;

            content += `<div class="tooltip-row">
                <span class="tooltip-label">ç·ã‚¨ãƒãƒ«ã‚®ãƒ¼:</span>
                <span class="tooltip-value">${info.totalEnergy}</span>
            </div>`;

            // å¤©ä½“ã‚¿ã‚¤ãƒ—åˆ¥ã®è¿½åŠ æƒ…å ±
            switch (body.type) {
                case 'pulsar':
                    if (info.magneticField) {
                        content += `<div class="tooltip-row">
                            <span class="tooltip-label">ç£å ´å¼·åº¦:</span>
                            <span class="tooltip-value">${info.magneticField}</span>
                        </div>`;
                    }
                    if (info.rotationPeriod) {
                        content += `<div class="tooltip-row">
                            <span class="tooltip-label">å›è»¢å‘¨æœŸ:</span>
                            <span class="tooltip-value">${info.rotationPeriod}s</span>
                        </div>`;
                    }
                    if (info.age !== null) {
                        content += `<div class="tooltip-row">
                            <span class="tooltip-label">å¹´é½¢:</span>
                            <span class="tooltip-value">${info.age}</span>
                        </div>`;
                    }
                    break;

                case 'neutronStar':
                    if (info.magneticField) {
                        content += `<div class="tooltip-row">
                            <span class="tooltip-label">ç£å ´å¼·åº¦:</span>
                            <span class="tooltip-value">${info.magneticField}</span>
                        </div>`;
                    }
                    break;

                case 'whiteDwarf':
                    if (info.temperature) {
                        content += `<div class="tooltip-row">
                            <span class="tooltip-label">æ¸©åº¦ä¿‚æ•°:</span>
                            <span class="tooltip-value">${info.temperature}</span>
                        </div>`;
                    }
                    break;

                case 'blackHole':
                    const eventHorizonRadius = body.eventHorizonRadius ? body.eventHorizonRadius.toFixed(1) : 'N/A';
                    content += `<div class="tooltip-row">
                        <span class="tooltip-label">äº‹è±¡åœ°å¹³ç·š:</span>
                        <span class="tooltip-value">${eventHorizonRadius}</span>
                    </div>`;
                    break;

                case 'planetSystem':
                    if (info.planets !== null) {
                        content += `<div class="tooltip-row">
                            <span class="tooltip-label">æƒ‘æ˜Ÿæ•°:</span>
                            <span class="tooltip-value">${info.planets}å€‹</span>
                        </div>`;
                    }
                    break;
            }

            tooltip.innerHTML = content;

            // ä½ç½®èª¿æ•´ï¼ˆç”»é¢ç«¯ã§ã®è¡¨ç¤ºã‚’è€ƒæ…®ï¼‰
            const rect = canvas.getBoundingClientRect();
            const tooltipRect = tooltip.getBoundingClientRect();

            let left = rect.left + x + 15;
            let top = rect.top + y - 10;

            // å³ç«¯ãƒã‚§ãƒƒã‚¯
            if (left + tooltipRect.width > window.innerWidth - 10) {
                left = rect.left + x - tooltipRect.width - 15;
            }

            // ä¸‹ç«¯ãƒã‚§ãƒƒã‚¯
            if (top + tooltipRect.height > window.innerHeight - 10) {
                top = rect.top + y - tooltipRect.height - 15;
            }

            // ä¸Šç«¯ãƒã‚§ãƒƒã‚¯
            if (top < 10) {
                top = rect.top + y + 15;
            }

            tooltip.style.left = `${left}px`;
            tooltip.style.top = `${top}px`;
            tooltip.style.display = 'block';
        }

        /**
         * â˜… è¿½åŠ ï¼šãƒ„ãƒ¼ãƒ«ãƒãƒƒãƒ—ã®éè¡¨ç¤º
         */
        function hideTooltip() {
            if (tooltip) {
                tooltip.style.display = 'none';
            }
            hoveredBody = null;
        }

        // â˜… ä¿®æ­£ï¼šãƒã‚¦ã‚¹ã‚¤ãƒ™ãƒ³ãƒˆå‡¦ç†ã‚’æ‹¡å¼µ
        function getEventPos(e) {
            const rect = canvas.getBoundingClientRect();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            return {
                x: clientX - rect.left,
                y: clientY - rect.top
            };
        }

        function findBodyAt(x, y) {
            for (let body of bodies) {
                if (!body.isValid) continue;
                const dx = x - body.x;
                const dy = y - body.y;
                const radius = Math.sqrt(body.mass) * 1.5;
                if (dx * dx + dy * dy <= radius * radius) {
                    return body;
                }
            }
            return null;
        }

        // â˜… è¿½åŠ ï¼šãƒã‚¦ã‚¹ç§»å‹•æ™‚ã®å‡¦ç†
        function handleMouseMove(e) {
            if (isDragging && selectedBody) {
                const pos = getEventPos(e);
                selectedBody.x = pos.x - dragOffset.x;
                selectedBody.y = pos.y - dragOffset.y;
                selectedBody.vx = 0;
                selectedBody.vy = 0;
                selectedBody.trail = [];
                return;
            }

            // ãƒ„ãƒ¼ãƒ«ãƒãƒƒãƒ—å‡¦ç†
            const pos = getEventPos(e);
            mousePos = pos;

            const bodyAtMouse = findBodyAt(pos.x, pos.y);

            if (bodyAtMouse && bodyAtMouse !== hoveredBody) {
                hoveredBody = bodyAtMouse;
                updateTooltip(bodyAtMouse, pos.x, pos.y);
                canvas.style.cursor = 'pointer';
            } else if (!bodyAtMouse && hoveredBody) {
                hideTooltip();
                canvas.style.cursor = 'crosshair';
            } else if (bodyAtMouse === hoveredBody && tooltip && tooltip.style.display === 'block') {
                // åŒã˜å¤©ä½“ã®ä¸Šã§ãƒã‚¦ã‚¹ãŒå‹•ã„ã¦ã„ã‚‹å ´åˆã€ä½ç½®ã®ã¿æ›´æ–°
                updateTooltip(bodyAtMouse, pos.x, pos.y);
            }
        }

        // ã‚¿ãƒƒãƒãƒ»ãƒã‚¦ã‚¹ã‚¤ãƒ™ãƒ³ãƒˆã®ç™»éŒ²
        canvas.addEventListener('touchstart', handleStart, { passive: false });
        canvas.addEventListener('touchmove', (e) => {
            if (isDragging) {
                handleMove(e);
            }
        }, { passive: false });
        canvas.addEventListener('mousedown', handleStart);
        canvas.addEventListener('mousemove', handleMouseMove); // â˜… ä¿®æ­£ï¼šæ–°ã—ã„ãƒãƒ³ãƒ‰ãƒ©ãƒ¼ã‚’ä½¿ç”¨
        canvas.addEventListener('touchend', handleEnd);
        canvas.addEventListener('mouseup', handleEnd);

        // â˜… è¿½åŠ ï¼šãƒã‚¦ã‚¹ãŒã‚­ãƒ£ãƒ³ãƒã‚¹ã‹ã‚‰é›¢ã‚ŒãŸæ™‚ã®å‡¦ç†
        canvas.addEventListener('mouseleave', hideTooltip);

        function handleStart(e) {
            e.preventDefault();
            const pos = getEventPos(e);
            const body = findBodyAt(pos.x, pos.y);

            if (body) {
                selectedBody = body;
                isDragging = true;
                dragOffset.x = pos.x - body.x;
                dragOffset.y = pos.y - body.y;
                canvas.style.cursor = 'grabbing';
                hideTooltip(); // ãƒ‰ãƒ©ãƒƒã‚°é–‹å§‹æ™‚ã¯ãƒ„ãƒ¼ãƒ«ãƒãƒƒãƒ—ã‚’éè¡¨ç¤º
            } else {
                // æ–°ã—ã„å¤©ä½“ã‚’ä½œæˆï¼ˆåˆæœŸé€Ÿåº¦ã‚’å°ã•ãèª¿æ•´ï¼‰
                if (bodies.length < 20) {
                    const newBody = new Body(pos.x, pos.y,
                        (Math.random() - 0.5) * 50,
                        (Math.random() - 0.5) * 50,
                        20 + Math.random() * 15);
                    bodies.push(newBody);
                    updateDisplay();
                }
                hideTooltip();
            }
        }

        function handleMove(e) {
            if (isDragging && selectedBody) {
                e.preventDefault();
                const pos = getEventPos(e);
                selectedBody.x = pos.x - dragOffset.x;
                selectedBody.y = pos.y - dragOffset.y;
                selectedBody.vx = 0;
                selectedBody.vy = 0;
                selectedBody.trail = [];
            }
        }

        function handleEnd(e) {
            isDragging = false;
            selectedBody = null;
            canvas.style.cursor = 'crosshair';
        }

        // åˆæœŸåŒ–
        try {
            // â˜… è¿½åŠ ï¼šãƒ„ãƒ¼ãƒ«ãƒãƒƒãƒ—ã®åˆæœŸåŒ–
            initializeTooltip();

            // ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã®åˆæœŸå€¤ã‚’è¨­å®š
            document.getElementById('speedValue').textContent = speed.toFixed(1);
            document.getElementById('gravityValue').textContent = gravity;
            document.getElementById('trailValue').textContent = trailLength;
            // â˜… è¿½åŠ ï¼šè¡çªåˆ¤å®šæ„Ÿåº¦ã®åˆæœŸå€¤è¨­å®š
            document.getElementById('collisionSensitivityValue').textContent = collisionSensitivity.toFixed(1);

            // é‡åŠ›å ´ã‚­ãƒ£ãƒ³ãƒã‚¹ã®åˆæœŸåŒ–
            setupGravityFieldCanvas();

            updateDisplay();
            drawBackground();

            // â˜… ä¿®æ­£ï¼šãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ç›£è¦–ã®æ”¹å–„
            setInterval(() => {
                if (currentFps < 25 && isRunning) { // â˜… ä¿®æ­£ï¼šé–¾å€¤ã‚’ä¸‹ã’ã‚‹
                    console.warn(`Low FPS detected: ${currentFps}, Bodies: ${bodies.length}, Particles: ${particles.length}`);

                    // â˜… è¿½åŠ ï¼šè‡ªå‹•ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹èª¿æ•´
                    if (particles.length > 200) {
                        particles.splice(0, particles.length - 150);
                        console.log('Particles reduced for performance');
                    }
                }
            }, 5000);

            console.log('ä¸‰ä½“å•é¡Œã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ãŒåˆæœŸåŒ–ã•ã‚Œã¾ã—ãŸã€‚');

        } catch (error) {
            console.error('Initialization error:', error);
            showError('åˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚');
        }
    </script>
</body>

</html>